var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Writing-and-reading-a-time-series-into-a-file","page":"Examples","title":"Writing and reading a time series into a file","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will demonstrate how to save a time series into a csv or binary file.  The first step is to obtain the data that you wish to save","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n#Creates dummy data\nn_blocks = 2\nn_scenarios = 3\nn_stages = 4\nn_agents = 5\n\ntime_series_data = rand(Float64, n_agents, n_blocks, n_scenarios, n_stages)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are two ways of saving the data to a file, save the data in the file directly or iteratively. To save the data directly use the function PSRI.array_to_file by calling:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FILE_PATH = joinpath(\".\", \"example\")\n\nPSRI.array_to_file(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    time_series_data,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"MW\";\n    initial_stage = 3,\n    initial_year = 2006,\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To save the data iteractively use the function PSRI.open to create an PSRI.AbstractWriter. Save the data of each registry to the file using the function PSRI.write_registry and then close the data stream calling the function PSRI.close.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"iow = PSRI.open(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    blocks = n_blocks,\n    scenarios = n_scenarios,\n    stages = n_stages,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"MW\",\n    initial_stage = 1,\n    initial_year = 2006,\n)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.write_registry(\n        iow,\n        time_series_data[:, block, scenario, stage],\n        stage,\n        scenario,\n        block\n    )\nend\n\nPSRI.close(iow)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A similar logic can be used to read the data from a file. You can read it directly or iteratively. To read the data directly use the function PSRI.file_to_array or PSRI.file_to_array_and_header","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n\n@assert all(isapprox.(data_from_file, time_series_data, atol=1E-7))\n\ndata_from_file_and_header, header = PSRI.file_to_array_and_header(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n@assert all(isapprox.(data_from_file_and_header, time_series_data, atol=1E-7))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To read the data iteractively use the function PSRI.open to create an PSRI.AbstractReader and read each registry iteratively. At the end you should close the PSRI.AbstractReader by calling PSRI.close","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ior = PSRI.open(\n    PSRI.OpenBinary.Reader, \n    FILE_PATH;\n    use_header = false\n)\n\ndata_from_file = zeros(n_agents, n_blocks, n_scenarios, n_stages)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.next_registry(ior)\n    data_from_file[:, block, scenario, stage] = ior.data\nend\n\nPSRI.close(ior)\n\nrm(FILE_PATH; force = true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To choose the agents order use use_header and header","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=true,\n        header=[\"Agent 5\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 1\"]\n    )\n@assert all(isapprox.(data_from_file[1, :, :, :], time_series_data[end, :, :, :], atol=1E-7))\n@assert all(isapprox.(data_from_file[end, :, :, :], time_series_data[1, :, :, :], atol=1E-7))","category":"page"},{"location":"examples/#Reading-configuration-parameters","page":"Examples","title":"Reading configuration parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Most cases have configuration parameters such as the maximum number of iterations, the discount rate, the deficit cost etc. The function PSRI.configuration_parameter reads all the parameters from the cases.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CONFIGS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CONFIGS\n)\n\nPSRI.configuration_parameter(data, \"TaxaDesconto\", 0.0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])","category":"page"},{"location":"examples/#Reading-basic-thermal-generator-parameters","page":"Examples","title":"Reading basic thermal generator parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will map parameters of thermal generators at each stage of the study to a struct. Suppose in this case that our thermal generators has the following attributes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base.@kwdef mutable struct ThermalGenerators\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    generation_capacities::Vector{Float64} = Float64[]\n    therm2sys::Vector{Int32} = Int32[]\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first thing we must do is to initialize the reading procedure with the following commands:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THERMALS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THERMALS\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can initialize the struct with the parameters of the first stage using the function PSRI.mapped_vector","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"therm_gen = ThermalGenerators()\ntherm_gen.names = PSRI.get_name(data, \"PSRThermalPlant\")\ntherm_gen.codes = PSRI.get_code(data, \"PSRThermalPlant\")\ntherm_gen.generation_capacities = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\ntherm_gen.therm2sys = PSRI.get_map(data, \"PSRThermalPlant\", \"PSRSystem\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And afterwards we can update the parameters for each stage as follows.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"for stage in 1:PSRI.total_stages(data)\n    PSRI.go_to_stage(data, stage)\n    PSRI.update_vectors!(data)\n    println(\"Thermal generator 2 generation capacity at stage $stage $(therm_gen.generation_capacities[2])\")\nend","category":"page"},{"location":"examples/#Reading-basic-battery-parameters","page":"Examples","title":"Reading basic battery parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is very similar to \"Reading basic thermal generator parameters\", but it is necessary to be cautious about the diffence between elements. For instance, batteries have different parameters than thermal generators, therefore, our data structure must be defined accordingly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base.@kwdef mutable struct Batteries\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    charge_eff::Vector{Float64} = Float64[]\n    bat2sys::Vector{Int32} = Int32[]\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Stardard proceadure of reading data from file:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BATTERIES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And now the struct may be instantiated by setting its appropriate parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"batteries = Batteries()\nbatteries.names = PSRI.get_name(data, \"PSRBattery\")\nbatteries.codes = PSRI.get_code(data, \"PSRBattery\")\nbatteries.charge_eff = PSRI.mapped_vector(data, \"PSRBattery\", \"ChargeEffic\", Int32)\nbatteries.bat2sys = PSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")","category":"page"},{"location":"examples/#Determining-subsystem-from-a-certain-hydro-plant","page":"Examples","title":"Determining subsystem from a certain hydro plant","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will demonstrate how to make a simple use of a relationship map. That will be achieved by determining a subsystem from a certain hydro plant through its parameters. The program will initiate by the standard reading procedure:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_GAUGING = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso2\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_GAUGING\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, the maps between hydroplants and systems is retrieved by the get_map method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hyd2sys = PSRI.get_map(data, \"PSRHydroPlant\",\"PSRSystem\")","category":"page"},{"location":"examples/#Determining-buses-from-a-certain-thermal-plant","page":"Examples","title":"Determining buses from a certain thermal plant","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This case consists of a more advanced use of a relationship map. We'll determine which buses are linked to a given target thermal plant, while there is no direct relationship between both. Firstly, the study data is read:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BUS\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Whereas there is no direct link between buses and thermal plants, both are indirectly related through generators. Therefore, we must identify those relationships by calling get_map for each:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"gen2thermal = PSRI.get_map(data, \"PSRGenerator\",\"PSRThermalPlant\")\ngen2bus = PSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we can find which generators are linked to our target thermal plant by the indexes of gen2the:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"target_thermal = 1\ntarget_generator = findall(isequal(target_thermal), gen2thermal)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"target_generator now holds the indexes of generators that are linked to the buses we are trying to identify. With those at hand, the indexes of the buses are easily identifiable by:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"targetBus = gen2bus[target_generator]","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PSRClassesInterface module provides interfaces to access data structured by PSR to be used in its models. Currently there are two main interfaces. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface for studies. This interface is designed to read parameters from the files, some examples are deficit costs, fuel costs, currency, storage capacity etc.\nThe interface for reading and writing time series data. Time series data in the context of most studies have 4 dimensions (agents, stages, scenarios and blocks). Since studies of renewables with multiple agents, scenarios and stages can get quite big, we have designed different formats that are optimized to some objective (human readability, size, fast reading and writing, etc.).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both interfaces are defined as a set of methods that need to be implemented to make a different file format work. In this manual we will describe the abstract methods and give concrete examples of code to perform the work needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When using the PSRClassesInterface package in your codebase we strongly advise you to create a constant PSRI to keep the code concise and explicitly declare that a certain function came from PSRClassesInterface. This can be done by adding the following code to the top of the code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface","category":"page"},{"location":"manual/#Abstract-study-interface","page":"Manual","title":"Abstract study interface","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractStudyInterface\nPSRClassesInterface.RelationType\nPSRClassesInterface.StageType\nPSRClassesInterface.initialize_study\nPSRClassesInterface.get_vector\nPSRClassesInterface.max_elements\nPSRClassesInterface.get_map\nPSRClassesInterface.get_vector_map\nPSRClassesInterface.get_reverse_map\nPSRClassesInterface.get_reverse_vector_map\nPSRClassesInterface.get_parms\nPSRClassesInterface.get_code\nPSRClassesInterface.get_name\nPSRClassesInterface.mapped_vector\nPSRClassesInterface.go_to_stage\nPSRClassesInterface.go_to_dimension\nPSRClassesInterface.update_vectors!\nPSRClassesInterface.description\nPSRClassesInterface.total_stages\nPSRClassesInterface.total_scenarios\nPSRClassesInterface.total_blocks\nPSRClassesInterface.total_openings\nPSRClassesInterface.total_stages_per_year\nPSRClassesInterface.stage_duration\nPSRClassesInterface.block_duration\nPSRClassesInterface.block_from_stage_hour\nPSRClassesInterface.get_nonempty_vector","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractStudyInterface","page":"Manual","title":"PSRClassesInterface.AbstractStudyInterface","text":"AbstractStudyInterface\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.RelationType","page":"Manual","title":"PSRClassesInterface.RelationType","text":"RelationType\n\nPossible relation types used in mapping function such as get_map, get_reverse_map, etc.\n\nThe current possible relation types are:\n\nRELATION_1_TO_1\nRELATION_1_TO_N\nRELATION_FROM\nRELATION_TO\nRELATION_TURBINE_TO\nRELATION_SPILL_TO\nRELATION_INFILTRATE_TO\nRELATION_STORED_ENERGY_DONWSTREAM\nRELATION_BACKED\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.StageType","page":"Manual","title":"PSRClassesInterface.StageType","text":"PSRI.StageType\n\nPossible stage types used in for reading and writing time series files.\n\nThe current possible stage types are:\n\nSTAGE_UNKNOWN\nSTAGE_WEEK\nSTAGE_MONTH\nSTAGE_3MONTHS\nSTAGE_DAY\nSTAGE_13MONTHS\nSTAGE_2MONTHS\nSTAGE_4MONTHS\nSTAGE_6MONTHS\nSTAGE_YEAR\nSTAGE_DECADE\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.initialize_study","page":"Manual","title":"PSRClassesInterface.initialize_study","text":"initialize_study(::AbstractStudyInterface; kwargs...)\n\nInitialize all data structures of the study.\n\nnote: Differences between the OpenInterface and ClassicInterface\nEach study interface has its own set of kwargs... The easiest way to inspect the current available options is searching for this function on the Github repo of the desired interface.\n\nExample:\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector","page":"Manual","title":"PSRClassesInterface.get_vector","text":"get_vector\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_elements","page":"Manual","title":"PSRClassesInterface.max_elements","text":"max_elements(data::AbstractData, collection::String)\n\nReturns an Int32 with the maximum number of elements for a given collection.\n\nExample:\n\nPSRI.max_elements(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_map","page":"Manual","title":"PSRClassesInterface.get_map","text":"get_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    allow_empty::Bool = true,\n    relation_type::RelationType = RELATION_1_TO_1, # type of the direct relation\n)\n\nReturns a Vector{Int32} with the map between collections given a certain RelationType.\n\nExamples:\n\nPSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRThermalPlant\")\n\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_TURBINE_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_SPILL_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_INFILTRATE_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_STORED_ENERGY_DONWSTREAM)\n\n@test PSRI.get_map(data, \"PSRInterconnection\", \"PSRSystem\", relation_type = PSRI.RELATION_FROM)\n@test PSRI.get_map(data, \"PSRInterconnection\", \"PSRSystem\", relation_type = PSRI.RELATION_TO)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_map","page":"Manual","title":"PSRClassesInterface.get_vector_map","text":"get_vector_map(\n    data::Data,\n    collection_from::String,\n    collection_to::String;\n    relation_type::RelationType = RELATION_1_TO_N,\n)\n\nReturns a Vector{Vector{Int32}} to represent the relation between each element of collection_from to multiple elements of collection_to.\n\nSince multiple relations might be available one might need to specify relation_type.\n\nExample:\n\nPSRI.get_vector_map(data, \"PSRInterconnectionSumData\", \"PSRInterconnection\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRHydroPlant\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRThermalPlant\", relation_type = PSRI.RELATION_BACKED)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_map","page":"Manual","title":"PSRClassesInterface.get_reverse_map","text":"get_reverse_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_1,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Int32} with the relation reversed. Some relations cannot be reversed this way since they are not bijections, in this case use get_reverse_vector_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\nPSRI.get_reverse_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n# which is te reverse of\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n\n\nPSRI.get_reverse_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_vector_map","page":"Manual","title":"PSRClassesInterface.get_reverse_vector_map","text":"get_reverse_vector_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_N,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Vector{Int32}} with the relation reversed.\n\nSome relations are bijections, in these cases it is also possible to use use get_reverse_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\n# upstream turbining hydros\nPSRI.get_reverse_vector_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", original_relation_type = PSRI.RELATION_TURBINE_TO)\n# which is the reverse of\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_TURBINE_TO)\n\nPSRI.get_reverse_vector_map(data, \"PSRGenerator\", \"PSRBus\", original_relation_type = PSRI.RELATION_1_TO_1)\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms","page":"Manual","title":"PSRClassesInterface.get_parms","text":"get_parms(\n    data::AbstractData,\n    col::String,\n    name::String,\n    ::Type{T};\n    check_type::Bool = true,\n    check_parm::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in col to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parms(data, \"PSRBattery\", \"Einic\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"ChargeRamp\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"DischargeRamp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_code","page":"Manual","title":"PSRClassesInterface.get_code","text":"get_code(data::AbstractData, collection::String)\n\nReturns a Vector{Int32} containing the code of each element in collection.\n\nExample:\n\nPSRI.get_code(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_name","page":"Manual","title":"PSRClassesInterface.get_name","text":"get_name(data::AbstractData, collection::String)\n\nReturns a Vector{String} containing the name of each element in collection.\n\nExample:\n\nPSRI.get_name(data, \"PSRThermalPlant\")\nPSRI.get_name(data, \"PSRGaugingStation\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.mapped_vector","page":"Manual","title":"PSRClassesInterface.mapped_vector","text":"mapped_vector(\n    data::AbstractData,\n    col::String,\n    name::String,\n    ::Type{T},\n    dim1::String=\"\",\n    dim2::String=\"\";\n    ignore::Bool=false,\n    map_key = col, # reference for PSRMap pointer, if empty use class name\n    filters = String[], # for calling just within a subset instead of the full call\n) where T\n\nMaps a Vector{T} containing the elements in col to a vector in julia. When the function update_vectors!  is called the elements of the vector will be updated to the according elements registered at the current data.time_controller.\n\nExample:\n\nexisting = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"Existing\", Int32)\npot_inst = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\n\nFor more information please read the example Reading basic thermal generator parameters\n\nnote: Differences between the OpenInterface and ClassicInterface\nWhen using mapped_vector in the OpenInterface mode the vector will be mapped  with the correct values at first hand. When using mapped_vector in the  ClassicInterface mode you should call update_vectors! to get the  good values for the collection, otherwise you might only get a vector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_stage","page":"Manual","title":"PSRClassesInterface.go_to_stage","text":"go_to_stage(data::AbstractData, stage::Integer)\n\nGoes to the stage in the data time controller. \n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_dimension","page":"Manual","title":"PSRClassesInterface.go_to_dimension","text":"go_to_dimension(data::Data, name::String, value::Integer)\n\nMoves time controller reference of vectors indexed by dimension name to the index value.\n\nExample:\n\ncesp = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"CEsp\", Float64, \"segment\", \"block\")\n\nPSRI.go_to_stage(data, 1)\n\nPSRI.go_to_dimension(data, \"segment\", 1)\nPSRI.go_to_dimension(data, \"block\", 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.update_vectors!","page":"Manual","title":"PSRClassesInterface.update_vectors!","text":"update_vectors!(data::AbstractData)\n\nUpdate all mapped vectors according to the time controller inside data.\n\n\n\nupdate_vectors!(data::Data, filters::Vector{String})\n\nUpdate filtered classes of mapped vectors according to the time controller inside data.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.description","page":"Manual","title":"PSRClassesInterface.description","text":"description(data::Data)\n\nReturns the study description if available.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_stages","page":"Manual","title":"PSRClassesInterface.total_stages","text":"total_stages(data::AbstractData)\n\nReturns the total number of stages of the case.\n\nExample:\n\nPSRI.total_stages(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_scenarios","page":"Manual","title":"PSRClassesInterface.total_scenarios","text":"total_scenarios(data::AbstractData)\n\nReturns the total number of scenarios of the case.\n\nExample:\n\nPSRI.total_scenarios(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_blocks","page":"Manual","title":"PSRClassesInterface.total_blocks","text":"total_blocks(data::AbstractData)\n\nReturns the total number of blocks of the case.\n\nExample:\n\nPSRI.total_blocks(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_openings","page":"Manual","title":"PSRClassesInterface.total_openings","text":"total_openings(data::AbstractData)\n\nReturns the total number of openings of the case.\n\nExample:\n\nPSRI.total_openings(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_stages_per_year","page":"Manual","title":"PSRClassesInterface.total_stages_per_year","text":"total_stages_per_year(data::AbstractData)\n\nReturns the total number of stages per year of the case.\n\nExample:\n\nPSRI.total_stages_per_year(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.stage_duration","page":"Manual","title":"PSRClassesInterface.stage_duration","text":"stage_duration(data::AbstractData, t::Int = data.controller_stage)\n\nReturns the duration, in hours, of the stage t.\n\n\n\nstage_duration(data::AbstractData, date::Dates.Date)\n\nReturns the duration, in hours, at the stage corresponding to date.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.block_duration","page":"Manual","title":"PSRClassesInterface.block_duration","text":"block_duration(data::AbstractData, date::Dates.Date, b::Int)\n\nReturns the duration, in hours, of the block b at the stage corresponding to date.\n\n\n\nblock_duration(data::AbstractData, t::Int, b::Int)\n\nReturns the duration, in hours, of the block b at stage t.\n\n\n\nblock_duration(data::AbstractData, b::Int)\n\nReturns the duration, in hours, of the block b at the current stage, set by go_to_stage.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.block_from_stage_hour","page":"Manual","title":"PSRClassesInterface.block_from_stage_hour","text":"block_from_stage_hour(data::Data, t::Int, h::Int)\n\nReturns the block b associated with hour h at stage t.\n\n\n\nblock_from_stage_hour(data::Data, date::Dates.Date, h::Int)\n\nReturns the block b associated with hour h at date date.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_nonempty_vector","page":"Manual","title":"PSRClassesInterface.get_nonempty_vector","text":"get_nonempty_vector(\n    data::Data,\n    colllection::String,\n    attribute::String,\n)\n\nReturns a vector of booleans with the number of elements of the collection. true means the vector associated with the given attribute is non-emepty, false means it is empty.\n\nExample:\n\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"ChroGerMin\")\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"SpinningReserve\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#Abstract-reader-and-writer-interface","page":"Manual","title":"Abstract reader and writer interface","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractReader\nPSRClassesInterface.AbstractWriter\nPSRClassesInterface.file_to_array\nPSRClassesInterface.file_to_array_and_header\nPSRClassesInterface.open\nPSRClassesInterface.is_hourly\nPSRClassesInterface.hour_discretization\nPSRClassesInterface.max_stages\nPSRClassesInterface.max_scenarios\nPSRClassesInterface.max_blocks\nPSRClassesInterface.max_blocks_current\nPSRClassesInterface.max_blocks_stage\nPSRClassesInterface.max_agents\nPSRClassesInterface.stage_type\nPSRClassesInterface.initial_stage\nPSRClassesInterface.initial_year\nPSRClassesInterface.data_unit\nPSRClassesInterface.current_stage\nPSRClassesInterface.current_scenario\nPSRClassesInterface.current_block\nPSRClassesInterface.agent_names\nPSRClassesInterface.goto\nPSRClassesInterface.next_registry\nPSRClassesInterface.close\nPSRClassesInterface.convert_file\nPSRClassesInterface.convert\nPSRClassesInterface.add_reader!\nPSRClassesInterface.write_registry\nPSRClassesInterface.array_to_file","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractReader","page":"Manual","title":"PSRClassesInterface.AbstractReader","text":"PSRI.AbstractReader\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.AbstractWriter","page":"Manual","title":"PSRClassesInterface.AbstractWriter","text":"PSRI.AbstractWriter\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.file_to_array","page":"Manual","title":"PSRClassesInterface.file_to_array","text":"PSRI.file_to_array(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.file_to_array_and_header","page":"Manual","title":"PSRClassesInterface.file_to_array_and_header","text":"PSRI.file_to_array_and_header(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array and header\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.open","page":"Manual","title":"PSRClassesInterface.open","text":"PSRI.open(::Type{<:AbstractWriter}, path::String; kwargs...)\n\nMethod for opening file and registering time series data. If specified file doesn't exist, the method will create it, otherwise, the previous one will be overwritten. Returns updated AbstractWriter instance. \n\nArguments:\n\nwriter: AbstractWriter instance to be used for opening file.\npath: path to file.\n\nKeyword arguments:\n\nblocks: case's number of blocks.\nscenarios: case's number of scenarios.\nstages: case's number of stages.\nagents: list of element names.\nunit: dimension of the elements' data.\nis_hourly: if data is hourly. If yes, block dimension will be ignored.\nhour_discretization: sub-hour parameter to discretize an hour into minutes.\nname_length: length of element names.\nblock_type: case's type of block.\nscenarios_type: case's type of scenario.\nstage_type: case's type of stage.\ninitial_stage: stage at which to start registry.\ninitial_year: year at which to start registry.\nallow_unsafe_name_length: allow element names outside safety bounds.\n\nExamples: \n\nWriting and reading a time series into a file\n\n\n\nPSRI.open(reader::Type{<:AbstractReader}, path::String; kwargs...)\n\nMethod for opening file and reading time series data. Returns updated AbstractReader instance.\n\nArguments:\n\nreader::Type{<:AbstractReader}: AbstractReader instance to be used for opening file.\npath::String: path to file.\n\nKeyword arguments:\n\nis_hourly::Bool: if data to be read is hourly, other than blockly.\nstage_type::PSRI.StageType: the PSRI.StageType of the data, defaults to PSRI.STAGE_MONTH.\nheader::Vector{String}: if file has a header with metadata.\nuse_header::Bool: if data from header should be retrieved.\nfirst_stage::Dates.Date: stage at which start reading.\nverbose_header::Bool: if data from header should be displayed during execution.\n\nExamples: \n\nWriting and reading a time series into a file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.is_hourly","page":"Manual","title":"PSRClassesInterface.is_hourly","text":"PSRI.is_hourly(ior::AbstractReader)\n\nReturns a Bool indicating whether the data in the file read by PSRI.AbstractReader is hourly.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.hour_discretization","page":"Manual","title":"PSRClassesInterface.hour_discretization","text":"PSRI.hour_discretization(ior::AbstractReader)\n\nReturns an Int indicating the hour discretization.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_stages","page":"Manual","title":"PSRClassesInterface.max_stages","text":"PSRI.max_stages(ior::AbstractReader)\n\nReturns an Int indicating maximum number of stages in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_scenarios","page":"Manual","title":"PSRClassesInterface.max_scenarios","text":"PSRI.max_scenarios(ior::AbstractReader)\n\nReturns an Int indicating maximum number of scenarios in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks","page":"Manual","title":"PSRClassesInterface.max_blocks","text":"PSRI.max_blocks(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_current","page":"Manual","title":"PSRClassesInterface.max_blocks_current","text":"PSRI.max_blocks_current(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the cuurent stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_stage","page":"Manual","title":"PSRClassesInterface.max_blocks_stage","text":"PSRI.max_blocks_stage(ior::AbstractReader, t::Integer)\n\nReturns an Int indicating maximum number of blocks in the stage t in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_agents","page":"Manual","title":"PSRClassesInterface.max_agents","text":"PSRI.max_agents(ior::AbstractReader)\n\nReturns an Int indicating maximum number of agents in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.stage_type","page":"Manual","title":"PSRClassesInterface.stage_type","text":"stage_type\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_stage","page":"Manual","title":"PSRClassesInterface.initial_stage","text":"PSRI.initial_stage(ior::AbstractReader)\n\nReturns an Int indicating the initial stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_year","page":"Manual","title":"PSRClassesInterface.initial_year","text":"PSRI.initial_year(ior::AbstractReader)\n\nReturns an Int indicating the initial year in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.data_unit","page":"Manual","title":"PSRClassesInterface.data_unit","text":"PSRI.data_unit(ior::AbstractReader)\n\nReturns a String indicating the unit of the data in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_stage","page":"Manual","title":"PSRClassesInterface.current_stage","text":"PSRI.current_stage(ior::AbstractReader)\n\nReturns an Int indicating the current stage in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_scenario","page":"Manual","title":"PSRClassesInterface.current_scenario","text":"PSRI.current_scenario(ior::AbstractReader)\n\nReturns an Int indicating the current scenarios in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_block","page":"Manual","title":"PSRClassesInterface.current_block","text":"PSRI.current_block(ior::AbstractReader)\n\nReturns an Int indicating the current block in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.agent_names","page":"Manual","title":"PSRClassesInterface.agent_names","text":"PSRI.agent_names(ior::AbstractReader)\n\nReturns a Vector{String} with the agent names in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.goto","page":"Manual","title":"PSRClassesInterface.goto","text":"PSRI.goto(\n    ior::AbstractReader, \n    t::Integer, \n    s::Integer = 1, \n    b::Integer = 1\n)\n\nGoes to the registry of the stage t, scenario s and block b.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.next_registry","page":"Manual","title":"PSRClassesInterface.next_registry","text":"PSRI.next_registry(ior::AbstractReader)\n\nGoes to the next registry on the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.close","page":"Manual","title":"PSRClassesInterface.close","text":"PSRI.close(ior::AbstractReader)\n\nCloses the PSRI.AbstractReader instance.\n\n\n\nPSRI.close(iow::AbstractWriter)\n\nCloses the PSRI.AbstractWriter instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.convert_file","page":"Manual","title":"PSRClassesInterface.convert_file","text":"convert_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.add_reader!","page":"Manual","title":"PSRClassesInterface.add_reader!","text":"add_reader!\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.write_registry","page":"Manual","title":"PSRClassesInterface.write_registry","text":"PSRI.write_registry(\n    iow::AbstractWriter,\n    data::Vector{T},\n    stage::Integer,\n    scenario::Integer = 1,\n    block::Integer = 1,\n) where T <: Real\n\nWrites a data row into opened file through PSRI.AbstractWriter instance.\n\nArguments:\n\niow: PSRI.AbstractWriter instance to be used for accessing file.\ndata: elements data to be written.\nstage: stage of the data to be written.\nscenario: scenarios of the data to be written.\nblock: block of the data to be written.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.array_to_file","page":"Manual","title":"PSRClassesInterface.array_to_file","text":"PSRI.array_to_file\n\n\n\n\n\n","category":"function"},{"location":"#PSRClassesInterface-Documentation","page":"Home","title":"PSRClassesInterface Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository to read and write open-source formats for PSR models.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered so you can simply add it using Julia's Pkg manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PSRClassesInterface","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide","category":"page"}]
}
