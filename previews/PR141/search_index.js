var documenterSearchIndex = {"docs":
[{"location":"examples/reading_relations/#Reading-Relations","page":"Reading Relations","title":"Reading Relations","text":"","category":"section"},{"location":"examples/reading_relations/#Introduction-to-the-[PSRI.get_map](@ref)-method","page":"Reading Relations","title":"Introduction to the PSRI.get_map method","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"There are two dispatches for  the PSRI.get_map function.  The first requires the attribute name that represents the relation, while the second needs the PSRI.PMD.RelationType between the elements.","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Here is how this function works:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Let's say that in our study we have 3 PSRSerie and 2 PSRBus elements.  There is a relation between elements of these two collections represented by an attribute 'no2', where PSRSerie is the source and PSRBus is the target.","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"If we execute the following code:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"PSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no2\")","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"We could, as an example, get the following vector:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"[ 2 , 0 , 1 ]","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"This means that:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"the source element of index 1 in the collection PSRSerie is related to the target element of index 2 in the collection PSRBus. \nthe source element of index 2 in the collection PSRSerie is not related to any element from collection PSRBus\nthe source element of index 3 in the collection PSRSerie is related to the target element of index 1 in the collection PSRBus. ","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Note: There is also a PSRI.get_vector_map method that works just as PSRI.get_map. ","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Now we can move to a more practical example.","category":"page"},{"location":"examples/reading_relations/#Determining-subsystem-from-a-certain-hydro-plant","page":"Reading Relations","title":"Determining subsystem from a certain hydro plant","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"In this example we will demonstrate how to make a simple use of a relationship map. That will be achieved by determining a subsystem from a certain hydro plant through its parameters. The program will initiate by the standard reading procedure:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_GAUGING = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case2\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_GAUGING\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, the maps between hydroplants and systems is retrieved by the get_map method:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"hyd2sys = PSRI.get_map(data, \"PSRHydroPlant\",\"PSRSystem\", \"system\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/#Determining-buses-from-a-certain-thermal-plant","page":"Reading Relations","title":"Determining buses from a certain thermal plant","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"This case consists of a more advanced use of a relationship map. We'll determine which buses are linked to a given target thermal plant, while there is no direct relationship between both. Firstly, the study data is read:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BUS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Whereas there is no direct link between buses and thermal plants, both are indirectly related through generators. Therefore, we must identify those relationships by calling get_map for each:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"gen2thermal = PSRI.get_map(data, \"PSRGenerator\",\"PSRThermalPlant\", \"plant\")\ngen2bus = PSRI.get_map(data, \"PSRGenerator\", \"PSRBus\", \"bus\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, we can find which generators are linked to our target thermal plant by the indexes of gen2the:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"target_thermal = 1\ntarget_generator = findall(isequal(target_thermal), gen2thermal)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"target_generator now holds the indexes of generators that are linked to the buses we are trying to identify. With those at hand, the indexes of the buses are easily identifiable by:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"targetBus = gen2bus[target_generator]\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/#Determining-which-buses-are-connected-by-each-circuit","page":"Reading Relations","title":"Determining which buses are connected by each circuit","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Each circuit connects two buses, it starts from a bus and goes to another. In this example we'll discover these buses for each circuit and then we'll build an incidence matrix of buses by circuits. The first step is to read the data:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CIR_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CIR_BUS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, we get from which bus each circuit starts and which bus it goes to with get_map:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"cir2bus_to = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no1\")\ncir2bus_from = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no2\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Now we can build the incidence matrix. Each row corresponds to a circuit and each column corresponds to a bus. The element at the index (i,j) is -1 if the circuit i starts from the bus j, 1 if it goes to this bus, and 0 if they both have no relation:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\ncir_size = PSRI.max_elements(data, \"PSRSerie\")\nincidence_matrix = zeros(Float64, cir_size, bus_size)\nfor cir = 1:cir_size\n    incidence_matrix[cir, cir2bus_from[cir]] = -1.0\n    incidence_matrix[cir, cir2bus_to[cir]] = 1.0\nend\nincidence_matrix","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"","category":"page"},{"location":"examples/custom_study/#Customizing-a-Study","page":"Customizing a Study","title":"Customizing a Study","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"In this tutorial you will learn how to customize several items of your study.","category":"page"},{"location":"examples/custom_study/#How-we-define-the-template-for-our-studies","page":"Customizing a Study","title":"How we define the template for our studies","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"First of all, it's important to understand how we define the default rules for each collection in our study.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"Let's take a look at the function PSRI.create_study:","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"function create_study(\n    ::OpenInterface;\n    data_path::AbstractString = pwd(),\n    pmd_files::Vector{String} = String[],\n    pmds_path::AbstractString = PMD._PMDS_BASE_PATH,\n    defaults_path::Union{AbstractString,Nothing} = PSRCLASSES_DEFAULTS_PATH,\n    defaults::Union{Dict{String,Any},Nothing} = _load_defaults!(),\n    netplan::Bool = false,\n    model_template_path::Union{String,Nothing} = nothing,\n    study_collection::String = \"PSRStudy\",\n)","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"From our other examples, you will notice that we have never filled most of these parameters, leaving them with their default values. However, the following are important for working with custom Studies:","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"pmd_files or pmds_path\nmodel_template_path\ndefaults_path","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"A PMD is a .pmd file where we define collections and the metadata for each of their attributes. A Model Template is a JSON file where we map the name of collections in the PMD to their names in our Study. Finally, Defaults is also a JSON file where we set the default values for some - or all - attributes in collections.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When we create a study, we parse the PMD file(s) and the Model Template, creating the data.data_struct, a Dict that contains the metadata for attributes and their names. ","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When we create an element, PSRI uses data.data_struct to check if the values for the attributes that we have filled are in agreement with their definition(if they should be Vectors, Floats, ...) and if any attribute is missing. ","category":"page"},{"location":"examples/custom_study/#Defining-custom-structures-with-new-PMD-file","page":"Customizing a Study","title":"Defining custom structures with new PMD file","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When you already have your structures defined in a PMD file, you don't need to create them in runtime. First, save this code as a .pmd file, where we define a Study collection, different from PSRStudy and a PSRExtra collection. ","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"DEFINE_MODEL MODL:Custom_Study_Config\n\tPARM REAL \t\tValue1\n\tPARM REAL \t\tValue3\n\tPARM STRING     Text\nEND_MODEL\n\nDEFINE_MODEL MODL:Extra_Collection\n\tPARM REAL \t\tExtraValue\n\tPARM STRING     Text\nEND_MODEL","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"Now we need a Model Template file, to map our PMD Model to collections. Just as we did before, copy the following code into a file, but save it as a .json this time.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"[\n    {\n        \"classname\": \"CustomStudy\",\n        \"models\": [\"Custom_Study_Config\"]\n    },\n    {\n        \"classname\": \"PSRExtra\",\n        \"models\": [\"Extra_Collection\"]\n    }\n]","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"After that, we can create a Study with PSRI.create_study using a few extra mandatory parameters.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n\ntemp_path = joinpath(tempdir(), \"PSRI\")\njson_path = joinpath(path_to_directory, \"custom_json.json\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(), \n    data_path = temp_path, \n    pmds_path = path_to_directory, \n    model_template_path = json_path, \n    study_collection = \"CustomStudy\", \n    defaults = Dict{String,Any}(\n        \"CustomStudy\" => Dict{String,Any}(\n            \"AVId\" => \"avid\", \n            \"Text\" => \"custom\", \n            \"Value1\" => 1.0, \n            \"Value3\" => 2.0, \n            \"code\" => Int32(10), \n            \"name\" => \"name\"\n        )\n    )\n)\n","category":"page"},{"location":"examples/modification/#Modifying-a-Study","page":"Modifying a Study","title":"Modifying a Study","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"In this example we will be showing how to modify your study in runtime, adding/deleting elements, setting relations, ...","category":"page"},{"location":"examples/modification/#Creating-a-Study","page":"Modifying a Study","title":"Creating a Study","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"You can modify a pre-existing study or a new one with the following functions:","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.create_study &rarr; to create a new study;\nPSRI.initialize_study &rarr; to load an old study.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"In this example, we will be working with a new empty study.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"temp_path = joinpath(tempdir(), \"PSRI\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(); data_path = temp_path)","category":"page"},{"location":"examples/modification/#Adding-new-elements","page":"Modifying a Study","title":"Adding new elements","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"You can only add elements from collections that are available for your study. Here we will be using our default study configuration, but in another example you can learn how to work with a custom study. You can check which collections are available with PSRI.get_collections(data).","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Every study already comes with a PSRStudy element. So now we can add some elements with the function PSRI.create_element!, that returns the element's index in the collection.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"bus_1_index   = PSRI.create_element!(data, \"PSRBus\")\nserie_1_index = PSRI.create_element!(data, \"PSRSerie\")","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"When not specified, the attributes for the element are filled with their default values. But you can also set them manually. If you need, it is possible to see the attributes for a collection with PSRI.get_attributes(data, COLLECTION).","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"bus_2_index = PSRI.create_element!(\n    data, \"PSRBus\", \n    \"name\" => \"bus_name\", \n    \"Kv\" => 1.5, \n    \"code\"=> Int32(98), \n    \"icca\" => Int32(5), \n    \"AVId\" => \"bus_id\"\n    )\n\n# You don't need to set all attributes\n\nbus_3_index = PSRI.create_element!(\n    data, \"PSRBus\", \n    \"code\"=> Int32(10), \n    )","category":"page"},{"location":"examples/modification/#Setting-relations","page":"Modifying a Study","title":"Setting relations","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Some collections in a Study can have relations between some of their elements. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"A Relation has a source and a target element. We can check the available relations for an element when it is a source with PSRI.get_relations(COLLECTION). Just as for custom collections, you can learn how to customize relations in another tutorial.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.set_related!(\n    data, \n    \"PSRSerie\", \n    \"PSRBus\", \n    serie_1_index, \n    bus_1_index , \n    relation_type = PSRI.PMD.RELATION_FROM\n    )\n\nPSRI.set_related!(\n    data, \n    \"PSRSerie\", \n    \"PSRBus\", \n    serie_1_index, \n    bus_2_index , \n    relation_type = PSRI.PMD.RELATION_TO\n    )","category":"page"},{"location":"examples/modification/#Deleting-elements","page":"Modifying a Study","title":"Deleting elements","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"We can delete an element using PSRI.delete_element!. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRBus\", bus_3_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"However, if you try to delete an element that has a relation with any other, you will receive an error message. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"<span style=\"color:red\">ERROR:</span> Element PSRSerie cannot be deleted because it has relations with other elements","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"So first, you have to check the relations that the element has and delete them.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"To see the relations set to an element, use PSRI.relations_summary, which returns a list with the target element, with its index, pointing to the source element, also with its index.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRBus\", bus_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"1: PSRBus[1] ← PSRSerie[1]","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRBus\", bus_2_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"1: PSRBus[2] ← PSRSerie[1]","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"1: PSRSerie[1] → PSRBus[1] 2: PSRSerie[1] → PSRBus[2]","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Now we know that we have to delete two relations to be able to delete the PSRSerie element. For that, we use PSRI.delete_relation!.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_relation!(data, \"PSRSerie\", \"PSRBus\", serie_1_index, bus_1_index)\nPSRI.delete_relation!(data, \"PSRSerie\", \"PSRBus\", serie_1_index, bus_2_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"After that, we can easily delete our PSRSerie element.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"After that we can save our study to a JSON file, which can later be used to load the study again.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.write_data(data)","category":"page"},{"location":"examples/reading_demands/#Reading-Demands","page":"Reading Demands","title":"Reading Demands","text":"","category":"section"},{"location":"examples/reading_demands/#Determining-elasticity-and-value-of-demands","page":"Reading Demands","title":"Determining elasticity and value of demands","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"In this example we will read demand segments, obtain the value of demands, discover wheter each demand is elastic or inelastic, and then obtain the sums of demands by elasticity. The first step is to read the study data:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_DEM = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_DEM\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Whereas the demand varies according to the stage, we must specify the stage by calling go_to_stage:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"target_stage = 1\nPSRI.go_to_stage(data,target_stage)","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now, we can read the demand segments and the map between demands and demand segments, and then obtain the value of each demand:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"dem_seg = PSRI.mapped_vector(data, \"PSRDemandSegment\", \"Demanda\", Float64, \"block\")\n\nseg2dem = PSRI.get_map(data, \"PSRDemandSegment\", \"PSRDemand\", relation_type = PSRI.PMD.RELATION_1_TO_1)\n\ndem_size = PSRI.max_elements(data, \"PSRDemand\")\n\ndemand_values = zeros(dem_size)\n\nfor demand = 1:dem_size\n    demand_values[demand] = sum(dem_seg[i] for i = 1:length(dem_seg) if seg2dem[i] == demand)\nend\n\ndemand_values","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"We can discover the elasticity of each demand by calling get_parms with the parameter Elastico:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"demands_elasticity = PSRI.get_parms(data, \"PSRDemand\", \"Elastico\", Int32)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"If demands_elasticity[i] == 0 it means that the demand at index i is inelastic, and elastic if demands_elasticity[i] == 1. We can now obtain the total demands of each elasticity:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"total_elastic_demand = 0.0\ntotal_inelastic_demand = 0.0\n\nfor i = 1:dem_size\n    if demands_elasticity[i] == 0\n        total_inelastic_demand += demand_values[i]\n    else\n        total_elastic_demand += demand_values[i]\n    end\nend","category":"page"},{"location":"examples/reading_demands/#Determining-demands-values-of-each-bus","page":"Reading Demands","title":"Determining demands values of each bus","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we have the values of the demands, we can obtain the values of demand for each bus.  Each demand has a set of loads, which define how much of this demand corresponds to each bus.  We can begin by reading the loads and its relations with demands and buses:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"loads = PSRI.mapped_vector(data, \"PSRLoad\", \"P\", Float64, \"block\")\nlod2dem = PSRI.get_map(data, \"PSRLoad\", \"PSRDemand\", relation_type = PSRI.PMD.RELATION_1_TO_1)\nlod2bus = PSRI.get_map(data, \"PSRLoad\", \"PSRBus\", relation_type = PSRI.PMD.RELATION_1_TO_1)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"The values of the loads are weights in a kind of a weighted arithmetic mean of the buses for each demand. But the loads of each demand don't add up to 1, so they need to be normalized to represent fractions of the total:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"total_lod_bydem = zeros(dem_size)\nlod_size = PSRI.max_elements(data, \"PSRLoad\")\n\nfor i in 1:lod_size\n    total_lod_bydem[lod2dem[i]] += loads[i]\nend\n\nfor i in 1:lod_size\n    if total_lod_bydem[lod2dem[i]] > 0.0\n        loads[i] = loads[i]/total_lod_bydem[lod2dem[i]]\n    else\n        loads[i] = 0.0\n    end\nend\n\nloads","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we know the fraction of each demand that corresponds to each bus, and can easily define the total demand by bus:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\n\ndem_bybus = zeros(bus_size)\n\nfor lod = 1:lod_size\n    fraction = loads[lod]\n    dem = lod2dem[lod]\n    bus = lod2bus[lod] \n    dem_bybus[bus] += demand_values[dem]*fraction\nend\n\ndem_bybus","category":"page"},{"location":"examples/reading_demands/#Calculating-the-energy-prices-of-each-thermal-plant","page":"Reading Demands","title":"Calculating the energy prices of each thermal plant","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"The energy prices in a thermal plant deppends on the  the price of the fuel used, the specific consumption of this fuel and Operation and Maintenance cost. Again, we begin by reading the data:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THER_PRICES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THER_PRICES\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"We discover the necessary infos of the thermal plants indirectly through PSRFuelConsumption:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"fuelcons2ther = PSRI.get_map(data,\"PSRFuelConsumption\", \"PSRThermalPlant\"; relation_type = PSRI.PMD.RELATION_1_TO_1)\n\nther_size = PSRI.max_elements(data, \"PSRThermalPlant\")\nfuelcons_size = PSRI.max_elements(data, \"PSRFuelConsumption\")\nther2fuelcons = [[fc for fc = 1:fuelcons_size if fuelcons2ther[fc] == t] for t = 1:ther_size]\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Next, we get the O&M cost, the specific consumption and the relation with fuels of our fuels consumptions. Then we get the cost of each fuel. After calling mapped_vector we must call update_vectors!.","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"om_cost = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"O&MCost\", Float64)\nspec_consum = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"CEsp\", Float64, \"segment\", \"block\")\nfuelcons2fuel = PSRI.get_map(data, \"PSRFuelConsumption\", \"PSRFuel\"; relation_type = PSRI.PMD.RELATION_1_TO_1)\nfuel_cost = PSRI.mapped_vector(data, \"PSRFuel\", \"Custo\", Float64)\n\nPSRI.update_vectors!(data)","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we can calculate the price of the energy unity of each fuel consumption for each thermal plant:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"ther_prices = [zeros(0) for _ = 1:ther_size]\nfor ther = 1:ther_size\n    n_fuelcons = length(ther2fuelcons[ther])\n    prices = zeros(n_fuelcons)\n    for i = 1:n_fuelcons\n        fuelcons = ther2fuelcons[ther][i]\n        fuel = fuelcons2fuel[fuelcons]\n        prices[i] = om_cost[fuelcons] + spec_consum[fuelcons]*fuel_cost[fuel]\n    end\n    ther_prices[ther] = prices\nend\nther_prices","category":"page"},{"location":"examples/reading_parameters/#Reading-parameters","page":"Reading parameters","title":"Reading parameters","text":"","category":"section"},{"location":"examples/reading_parameters/#Reading-configuration-parameters","page":"Reading parameters","title":"Reading configuration parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Most cases have configuration parameters such as the maximum number of iterations, the discount rate, the deficit cost etc. The function PSRI.configuration_parameter reads all the parameters from the cases.","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CONFIGS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CONFIGS\n)\n\nPSRI.configuration_parameter(data, \"TaxaDesconto\", 0.0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/#Reading-basic-thermal-generator-parameters","page":"Reading parameters","title":"Reading basic thermal generator parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"In this example we will map parameters of thermal generators at each stage of the study to a struct. Suppose in this case that our thermal generators has the following attributes:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Base.@kwdef mutable struct ThermalGenerators\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    generation_capacities::Vector{Float64} = Float64[]\n    therm2sys::Vector{Int32} = Int32[]\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"The first thing we must do is to initialize the reading procedure with the following commands:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THERMALS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THERMALS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"We can initialize the struct with the parameters of the first stage using the function PSRI.mapped_vector","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"therm_gen = ThermalGenerators()\ntherm_gen.names = PSRI.get_name(data, \"PSRThermalPlant\")\ntherm_gen.codes = PSRI.get_code(data, \"PSRThermalPlant\")\ntherm_gen.generation_capacities = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\ntherm_gen.therm2sys = PSRI.get_map(data, \"PSRThermalPlant\", \"PSRSystem\")\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"And afterwards we can update the parameters for each stage as follows.","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"for stage in 1:PSRI.total_stages(data)\n    PSRI.go_to_stage(data, stage)\n    PSRI.update_vectors!(data)\n    println(\"Thermal generator 2 generation capacity at stage $stage $(therm_gen.generation_capacities[2])\")\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/#Reading-basic-battery-parameters","page":"Reading parameters","title":"Reading basic battery parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"This example is very similar to \"Reading basic thermal generator parameters\", but it is necessary to be cautious about the difference between elements. For instance, batteries have different parameters than thermal generators, therefore, our data structure must be defined accordingly:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Base.@kwdef mutable struct Batteries\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    charge_eff::Vector{Float64} = Float64[]\n    bat2sys::Vector{Int32} = Int32[]\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Stardard proceadure of reading data from file:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BATTERIES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"And now the struct may be instantiated by setting its appropriate parameters:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"batteries = Batteries()\nbatteries.names = PSRI.get_name(data, \"PSRBattery\")\nbatteries.codes = PSRI.get_code(data, \"PSRBattery\")\nbatteries.charge_eff = PSRI.mapped_vector(data, \"PSRBattery\", \"ChargeEffic\", Float64)\nbatteries.bat2sys = PSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\n; nothing # hide","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PSRClassesInterface module provides interfaces to access data structured by PSR to be used in its models. Currently there are two main interfaces. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface for studies. This interface is designed to read parameters from the files, some examples are deficit costs, fuel costs, currency, storage capacity etc.\nThe interface for reading and writing time series data. Time series data in the context of most studies have 4 dimensions (agents, stages, scenarios and blocks). Since studies of renewables with multiple agents, scenarios and stages can get quite big, we have designed different formats that are optimized to some objective (human readability, size, fast reading and writing, etc.).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both interfaces are defined as a set of methods that need to be implemented to make a different file format work. In this manual we will describe the abstract methods and give concrete examples of code to perform the work needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When using the PSRClassesInterface package in your codebase we strongly advise you to create a constant PSRI to keep the code concise and explicitly declare that a certain function came from PSRClassesInterface. This can be done by adding the following code to the top of the code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface","category":"page"},{"location":"manual/#Initialize-Study","page":"Manual","title":"Initialize Study","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractData\nPSRClassesInterface.AbstractStudyInterface\nPSRClassesInterface.initialize_study\nPSRClassesInterface.description\nPSRClassesInterface.max_elements","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractData","page":"Manual","title":"PSRClassesInterface.AbstractData","text":"AbstractData\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.AbstractStudyInterface","page":"Manual","title":"PSRClassesInterface.AbstractStudyInterface","text":"AbstractStudyInterface\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.initialize_study","page":"Manual","title":"PSRClassesInterface.initialize_study","text":"initialize_study(::AbstractStudyInterface; kwargs...)\n\nInitialize all data structures of the study.\n\nnote: Differences between the OpenInterface and ClassicInterface\nEach study interface has its own set of kwargs... The easiest way to inspect the current available options is searching for this function on the Github repo of the desired interface.\n\nExample:\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface();\n    data_path = PATH_CASE_EXAMPLE_BATTERIES,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.description","page":"Manual","title":"PSRClassesInterface.description","text":"description(data::AbstractData)\n\nReturns the study description if available.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_elements","page":"Manual","title":"PSRClassesInterface.max_elements","text":"max_elements(data::AbstractData, collection::String)\n\nReturns an Int32 with the maximum number of elements for a given collection.\n\nExample:\n\nPSRI.max_elements(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-dimensions","page":"Manual","title":"Study dimensions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.StageType\nPSRClassesInterface.total_stages\nPSRClassesInterface.total_scenarios\nPSRClassesInterface.total_blocks\nPSRClassesInterface.total_openings\nPSRClassesInterface.total_stages_per_year","category":"page"},{"location":"manual/#PSRClassesInterface.StageType","page":"Manual","title":"PSRClassesInterface.StageType","text":"PSRI.StageType\n\nPossible stage types used in for reading and writing time series files.\n\nThe current possible stage types are:\n\nSTAGE_UNKNOWN\nSTAGE_WEEK\nSTAGE_MONTH\nSTAGE_3MONTHS\nSTAGE_DAY\nSTAGE_13MONTHS\nSTAGE_2MONTHS\nSTAGE_4MONTHS\nSTAGE_6MONTHS\nSTAGE_YEAR\nSTAGE_DECADE\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.total_stages","page":"Manual","title":"PSRClassesInterface.total_stages","text":"total_stages(data::AbstractData)\n\nReturns the total number of stages of the case.\n\nExample:\n\nPSRI.total_stages(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_scenarios","page":"Manual","title":"PSRClassesInterface.total_scenarios","text":"total_scenarios(data::AbstractData)\n\nReturns the total number of scenarios of the case.\n\nExample:\n\nPSRI.total_scenarios(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_blocks","page":"Manual","title":"PSRClassesInterface.total_blocks","text":"total_blocks(data::AbstractData)\n\nReturns the total number of blocks of the case.\n\nExample:\n\nPSRI.total_blocks(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_openings","page":"Manual","title":"PSRClassesInterface.total_openings","text":"total_openings(data::AbstractData)\n\nReturns the total number of openings of the case.\n\nExample:\n\nPSRI.total_openings(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_stages_per_year","page":"Manual","title":"PSRClassesInterface.total_stages_per_year","text":"total_stages_per_year(data::AbstractData)\n\nReturns the total number of stages per year of the case.\n\nExample:\n\nPSRI.total_stages_per_year(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-duration-and-blocking","page":"Manual","title":"Study duration and blocking","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.BlockDurationMode\nPSRClassesInterface.stage_duration\nPSRClassesInterface.block_duration\nPSRClassesInterface.block_from_stage_hour","category":"page"},{"location":"manual/#Read-Scalar-Attributes","page":"Manual","title":"Read Scalar Attributes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.configuration_parameter\nPSRClassesInterface.get_code\nPSRClassesInterface.get_name\nPSRClassesInterface.get_parm\nPSRClassesInterface.get_parm_1d\nPSRClassesInterface.get_parms\nPSRClassesInterface.get_parms_1d","category":"page"},{"location":"manual/#PSRClassesInterface.configuration_parameter","page":"Manual","title":"PSRClassesInterface.configuration_parameter","text":"configuration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::T\n) where T <: MainTypes\n\nReturns the required configuration parameter from the case. If the parameter is not registered returns the default value.\n\nconfiguration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::Vector{T},\n) where T <: MainTypes\n\nReturns the rquired configuration parameters from the case that are vectors that are vectors. If the parameter is not registered returns the default value.\n\nExamples:\n\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\n\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_code","page":"Manual","title":"PSRClassesInterface.get_code","text":"get_code(data::AbstractData, collection::String)\n\nReturns a Vector{Int32} containing the code of each element in collection.\n\nExample:\n\nPSRI.get_code(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_name","page":"Manual","title":"PSRClassesInterface.get_name","text":"get_name(data::AbstractData, collection::String)\n\nReturns a Vector{String} containing the name of each element in collection.\n\nExample:\n\nPSRI.get_name(data, \"PSRThermalPlant\")\nPSRI.get_name(data, \"PSRGaugingStation\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm","page":"Manual","title":"PSRClassesInterface.get_parm","text":"get_parm(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm(data, \"PSRBattery\", \"Einic\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"ChargeRamp\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"DischargeRamp\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm_1d","page":"Manual","title":"PSRClassesInterface.get_parm_1d","text":"get_parm_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64, 1)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms","page":"Manual","title":"PSRClassesInterface.get_parms","text":"get_parms(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    check_type::Bool = true,\n    check_parm::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parms(data, \"PSRBattery\", \"Einic\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"ChargeRamp\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"DischargeRamp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms_1d","page":"Manual","title":"PSRClassesInterface.get_parms_1d","text":"get_parms_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    check_type::Bool = true,\n    check_parm::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-Vector-Attributes","page":"Manual","title":"Read Vector Attributes","text":"","category":"section"},{"location":"manual/#Time-controller","page":"Manual","title":"Time controller","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.mapped_vector\nPSRClassesInterface.go_to_stage\nPSRClassesInterface.go_to_dimension\nPSRClassesInterface.update_vectors!","category":"page"},{"location":"manual/#PSRClassesInterface.mapped_vector","page":"Manual","title":"PSRClassesInterface.mapped_vector","text":"mapped_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n    dim1::String=\"\",\n    dim2::String=\"\";\n    ignore::Bool=false,\n    map_key = collection, # reference for PSRMap pointer, if empty use class name\n    filters = String[], # for calling just within a subset instead of the full call\n) where T\n\nMaps a Vector{T} containing the elements in collection to a vector in julia. When the function update_vectors! is called the elements of the vector will be updated to the according elements registered at the current data.time_controller.\n\nExample:\n\nexisting = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"Existing\", Int32)\npot_inst = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\n\nFor more information please read the example Reading basic thermal generator parameters\n\nnote: Differences between the OpenInterface and ClassicInterface\nWhen using mapped_vector in the OpenInterface mode the vector will be mapped with the correct values at first hand. When using mapped_vector in the ClassicInterface mode you should call update_vectors! to get the good values for the collection, otherwise you might only get a vector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_stage","page":"Manual","title":"PSRClassesInterface.go_to_stage","text":"go_to_stage(data::AbstractData, stage::Integer)\n\nGoes to the stage in the data time controller.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_dimension","page":"Manual","title":"PSRClassesInterface.go_to_dimension","text":"go_to_dimension(data::AbstractData, name::String, value::Integer)\n\nMoves time controller reference of vectors indexed by dimension name to the index value.\n\nExample:\n\ncesp = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"CEsp\", Float64, \"segment\", \"block\")\n\nPSRI.go_to_stage(data, 1)\n\nPSRI.go_to_dimension(data, \"segment\", 1)\nPSRI.go_to_dimension(data, \"block\", 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.update_vectors!","page":"Manual","title":"PSRClassesInterface.update_vectors!","text":"update_vectors!(data::AbstractData)\n\nUpdate all mapped vectors according to the time controller inside data.\n\nupdate_vectors!(data::AbstractData, filters::Vector{String})\n\nUpdate filtered classes of mapped vectors according to the time controller inside data.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Direct-access","page":"Manual","title":"Direct access","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_vector\nPSRClassesInterface.get_vector_1d\nPSRClassesInterface.get_vector_2d\nPSRClassesInterface.get_vectors\nPSRClassesInterface.get_vectors_1d\nPSRClassesInterface.get_vectors_2d\nPSRClassesInterface.get_nonempty_vector\nPSRClassesInterface.get_series","category":"page"},{"location":"manual/#PSRClassesInterface.get_vector","page":"Manual","title":"PSRClassesInterface.get_vector","text":"PSRI.get_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} of entries of the attribute of collection at the element with index index.\n\nExample:\n\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Vazao\", 1, Float64)\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Data\", 1, Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_1d","page":"Manual","title":"PSRClassesInterface.get_vector_1d","text":"PSRI.get_vector_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection at the element with index index. The outer vector contains one entry per index in dimension 1, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_1d(data, \"PSRArea\", \"Export\", 1, Float64)\nPSRI.get_vector_1d(data, \"PSRLoad\", \"P\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_2d","page":"Manual","title":"PSRClassesInterface.get_vector_2d","text":"PSRI.get_vector_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Matrix{Vector{T}} of entries of the attribute of collection at the element with index index. The outer matrix contains one entry per index in dimension 1 and dimension 2, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_2d(data, \"PSRThermalPlant\", \"CEsp\", 1, Float64)\nPSRI.get_vector_2d(data, \"PSRFuelConsumption\", \"CEsp\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors","page":"Manual","title":"PSRClassesInterface.get_vectors","text":"PSRI.get_vectors(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection.\n\nExample:\n\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Vazao\", Float64)\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Data\", Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_1d","page":"Manual","title":"PSRClassesInterface.get_vectors_1d","text":"PSRI.get_vectors_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Vector{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the 2 inner vectors see get_vector_1d.\n\nExample:\n\nPSRI.get_vectors_1d(data, \"PSRArea\", \"Export\", Float64)\nPSRI.get_vectors_1d(data, \"PSRLoad\", \"P\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_2d","page":"Manual","title":"PSRClassesInterface.get_vectors_2d","text":"PSRI.get_vectors_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Matrix{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the Matrix{Vector{T}} see get_vector_2d.\n\nExample:\n\nPSRI.get_vectors_2d(data, \"PSRThermalPlant\", \"CEsp\", Float64)\nPSRI.get_vectors_2d(data, \"PSRFuelConsumption\", \"CEsp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_nonempty_vector","page":"Manual","title":"PSRClassesInterface.get_nonempty_vector","text":"get_nonempty_vector(\n    data::AbstractData,\n    colllection::String,\n    attribute::String,\n)\n\nReturns a vector of booleans with the number of elements of the collection. true means the vector associated with the given attribute is non-emepty, false means it is empty.\n\nExample:\n\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"ChroGerMin\")\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"SpinningReserve\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_series","page":"Manual","title":"PSRClassesInterface.get_series","text":"function get_series(\n    data::Data,\n    collection::String,\n    indexing_attribute::String,\n    index::Int,\n)\n\nRetrieves a SeriesTable object with all attributes from an element that are indexed by index_attr.\n\nExample\n\njulia> PSRI.get_series(data, \"PSRThermalPlant\", \"Data\", 1)\nDict{String, Vector} with 13 entries:\n  \"GerMin\"   => [0.0]\n  \"GerMax\"   => [888.0]\n  \"NGas\"     => [nothing]\n  \"IH\"       => [0.0]\n  \"ICP\"      => [0.0]\n  \"Data\"     => [\"1900-01-01\"]\n  \"CoefE\"    => [1.0]\n  \"PotInst\"  => [888.0]\n  \"Existing\" => [0]\n  \"sfal\"     => [0]\n  \"NAdF\"     => [0]\n  \"Unidades\" => [1]\n  \"StartUp\"  => [0.0]\n\n\n\n\n\n","category":"function"},{"location":"manual/#Relations-between-collections","page":"Manual","title":"Relations between collections","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.RelationType\nPSRClassesInterface.is_vector_relation\nPSRClassesInterface.get_map\nPSRClassesInterface.get_vector_map\nPSRClassesInterface.get_reverse_map\nPSRClassesInterface.get_reverse_vector_map\nPSRClassesInterface.get_related\nPSRClassesInterface.get_vector_related","category":"page"},{"location":"manual/#PSRClassesInterface.is_vector_relation","page":"Manual","title":"PSRClassesInterface.is_vector_relation","text":"is_vector_relation(relation::PMD.RelationType)\n\nReturns true is relation is a vector relation.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_map","page":"Manual","title":"PSRClassesInterface.get_map","text":"get_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    allow_empty::Bool = true,\n    relation_type::RelationType = RELATION_1_TO_1, # type of the direct relation\n)\n\nReturns a Vector{Int32} with the map between collections given a certain RelationType.\n\nExamples:\n\nPSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRThermalPlant\")\n\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_SPILL_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_INFILTRATE_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_STORED_ENERGY_DONWSTREAM,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_map","page":"Manual","title":"PSRClassesInterface.get_vector_map","text":"get_vector_map(\n    data::AbstractData,\n    collection_from::String,\n    collection_to::String;\n    relation_type::RelationType = RELATION_1_TO_N,\n)\n\nReturns a Vector{Vector{Int32}} to represent the relation between each element of collection_from to multiple elements of collection_to.\n\nSince multiple relations might be available one might need to specify relation_type.\n\nExample:\n\nPSRI.get_vector_map(data, \"PSRInterconnectionSumData\", \"PSRInterconnection\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRHydroPlant\")\nPSRI.get_vector_map(\n    data,\n    \"PSRReserveGenerationConstraintData\",\n    \"PSRThermalPlant\";\n    relation_type = PSRI.PMD.RELATION_BACKED,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_map","page":"Manual","title":"PSRClassesInterface.get_reverse_map","text":"get_reverse_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_1,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Int32} with the relation reversed. Some relations cannot be reversed this way since they are not bijections, in this case use get_reverse_vector_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\nPSRI.get_reverse_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n# which is te reverse of\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n\nPSRI.get_reverse_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_vector_map","page":"Manual","title":"PSRClassesInterface.get_reverse_vector_map","text":"get_reverse_vector_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_N,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Vector{Int32}} with the relation reversed.\n\nSome relations are bijections, in these cases it is also possible to use use get_reverse_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\n# upstream turbining hydros\nPSRI.get_reverse_vector_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    original_relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\n# which is the reverse of\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\n\nPSRI.get_reverse_vector_map(\n    data,\n    \"PSRGenerator\",\n    \"PSRBus\";\n    original_relation_type = PSRI.PMD.RELATION_1_TO_1,\n)\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_related","page":"Manual","title":"PSRClassesInterface.get_related","text":"get_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_1,\n)\n\nReturns the index of the element in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_related","page":"Manual","title":"PSRClassesInterface.get_vector_related","text":"get_vector_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_N,\n)\n\nReturns the vector of indices of the elements in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reflection","page":"Manual","title":"Reflection","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_attribute_dim1\nPSRClassesInterface.get_attribute_dim2\nPSRClassesInterface.get_collections\nPSRClassesInterface.get_attributes\nPSRClassesInterface.get_attribute_struct\nPSRClassesInterface.get_data_struct\nPSRClassesInterface.Attribute\nPSRClassesInterface.get_attributes_indexed_by\nPSRClassesInterface.get_relations\nPSRClassesInterface.get_attribute_dim","category":"page"},{"location":"manual/#PSRClassesInterface.get_attribute_dim1","page":"Manual","title":"PSRClassesInterface.get_attribute_dim1","text":"get_attribute_dim1(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 1 of attribute from collection at element index. Errors if attribute has zero dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim2","page":"Manual","title":"PSRClassesInterface.get_attribute_dim2","text":"get_attribute_dim2(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 2 of attribute from collection at element index. Errors if attribute has zero or one dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_collections","page":"Manual","title":"PSRClassesInterface.get_collections","text":"get_collections(data::AbstractData)\n\nReturn Vector{String} of valid collections (depends on loaded pmd files).\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attributes","page":"Manual","title":"PSRClassesInterface.get_attributes","text":"get_attributes(data::AbstractData, collection::String)\n\nReturn Vector{String} of valid attributes from collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_struct","page":"Manual","title":"PSRClassesInterface.get_attribute_struct","text":"get_attribute_struct(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n)\n\nReturns a struct of type Attribute with fields:\n\nname::String = attribute name\nis_vector::Bool = true if attribute is a vector (tipically, varies in time)\ntype::DataType = attribute type (tipically: Int32, Float64, String, Dates.Date)\ndim::Int = number of additional dimensions\nindex::String = if a vector represents the indexing vector (might be empty)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_data_struct","page":"Manual","title":"PSRClassesInterface.get_data_struct","text":"get_attribute_struct(data::AbstractData)\n\nReturn a struct of type DataStruct with collection names (strings) as keys and maps from attributes names (string) to attributes data definitions Attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.Attribute","page":"Manual","title":"PSRClassesInterface.Attribute","text":"struct Attribute\n    name::String\n    is_vector::Bool\n    type::DataType\n    dim::Int\n    index::String\nend\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.get_attributes_indexed_by","page":"Manual","title":"PSRClassesInterface.get_attributes_indexed_by","text":"get_attributes_indexed_by(\n    data::AbstractData,\n    collection::String,\n    indexing_attribute::String\n)\n\nReturn Vector{String} of valid vector attributes from collection that are indexed by indexing_attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_relations","page":"Manual","title":"PSRClassesInterface.get_relations","text":"get_relations(data::AbstractData, collection::String)\n\nReturns a Tuple{String, Vector{PMD.Relation}} with relating collection and their relation type associated to collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim","page":"Manual","title":"PSRClassesInterface.get_attribute_dim","text":"get_attribute_dim(attribute_struct::Attribute)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-Graf-files","page":"Manual","title":"Write Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractWriter\nPSRClassesInterface.open\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractWriter","page":"Manual","title":"PSRClassesInterface.AbstractWriter","text":"PSRI.AbstractWriter\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.open","page":"Manual","title":"PSRClassesInterface.open","text":"PSRI.open(::Type{<:AbstractWriter}, path::String; kwargs...)\n\nMethod for opening file and registering time series data. If specified file doesn't exist, the method will create it, otherwise, the previous one will be overwritten. Returns updated AbstractWriter instance.\n\nArguments:\n\nwriter: AbstractWriter instance to be used for opening file.\npath: path to file.\n\nKeyword arguments:\n\nblocks: case's number of blocks.\nscenarios: case's number of scenarios.\nstages: case's number of stages.\nagents: list of element names.\nunit: dimension of the elements' data.\nis_hourly: if data is hourly. If yes, block dimension will be ignored.\nhour_discretization: sub-hour parameter to discretize an hour into minutes.\nname_length: length of element names.\nblock_type: case's type of block.\nscenarios_type: case's type of scenario.\nstage_type: case's type of stage.\ninitial_stage: stage at which to start registry.\ninitial_year: year at which to start registry.\nallow_unsafe_name_length: allow element names outside safety bounds.\n\nExamples:\n\nWriting and reading a time series into a file\n\nPSRI.open(reader::Type{<:AbstractReader}, path::String; kwargs...)\n\nMethod for opening file and reading time series data. Returns updated AbstractReader instance.\n\nArguments:\n\nreader::Type{<:AbstractReader}: AbstractReader instance to be used for opening file.\npath::String: path to file.\n\nKeyword arguments:\n\nis_hourly::Bool: if data to be read is hourly, other than blockly.\nstage_type::PSRI.StageType: the PSRI.StageType of the data, defaults to PSRI.STAGE_MONTH.\nheader::Vector{String}: if file has a header with metadata.\nuse_header::Bool: if data from header should be retrieved.\nfirst_stage::Dates.Date: stage at which start reading.\nverbose_header::Bool: if data from header should be displayed during execution.\n\nExamples:\n\nWriting and reading a time series into a file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.close","page":"Manual","title":"PSRClassesInterface.close","text":"PSRI.close(ior::AbstractReader)\n\nCloses the PSRI.AbstractReader instance.\n\n\nPSRI.close(iow::AbstractWriter)\n\nCloses the PSRI.AbstractWriter instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-entire-file","page":"Manual","title":"Write entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.array_to_file","category":"page"},{"location":"manual/#PSRClassesInterface.array_to_file","page":"Manual","title":"PSRClassesInterface.array_to_file","text":"PSRI.array_to_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-registry","page":"Manual","title":"Write registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.write_registry","category":"page"},{"location":"manual/#PSRClassesInterface.write_registry","page":"Manual","title":"PSRClassesInterface.write_registry","text":"PSRI.write_registry(\n    iow::AbstractWriter,\n    data::Vector{T},\n    stage::Integer,\n    scenario::Integer = 1,\n    block::Integer = 1,\n) where T <: Real\n\nWrites a data row into opened file through PSRI.AbstractWriter instance.\n\nArguments:\n\niow: PSRI.AbstractWriter instance to be used for accessing file.\ndata: elements data to be written.\nstage: stage of the data to be written.\nscenario: scenarios of the data to be written.\nblock: block of the data to be written.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-Graf-files","page":"Manual","title":"Read Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close-2","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractReader\nPSRClassesInterface.open\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractReader","page":"Manual","title":"PSRClassesInterface.AbstractReader","text":"PSRI.AbstractReader\n\n\n\n\n\n","category":"type"},{"location":"manual/#Header-information","page":"Manual","title":"Header information","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.is_hourly\nPSRClassesInterface.hour_discretization\nPSRClassesInterface.max_stages\nPSRClassesInterface.max_scenarios\nPSRClassesInterface.max_blocks\nPSRClassesInterface.max_blocks_current\nPSRClassesInterface.max_blocks_stage\nPSRClassesInterface.max_agents\nPSRClassesInterface.stage_type\nPSRClassesInterface.initial_stage\nPSRClassesInterface.initial_year\nPSRClassesInterface.data_unit\nPSRClassesInterface.agent_names","category":"page"},{"location":"manual/#PSRClassesInterface.is_hourly","page":"Manual","title":"PSRClassesInterface.is_hourly","text":"PSRI.is_hourly(ior::AbstractReader)\n\nReturns a Bool indicating whether the data in the file read by PSRI.AbstractReader is hourly.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.hour_discretization","page":"Manual","title":"PSRClassesInterface.hour_discretization","text":"PSRI.hour_discretization(ior::AbstractReader)\n\nReturns an Int indicating the hour discretization.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_stages","page":"Manual","title":"PSRClassesInterface.max_stages","text":"PSRI.max_stages(ior::AbstractReader)\n\nReturns an Int indicating maximum number of stages in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_scenarios","page":"Manual","title":"PSRClassesInterface.max_scenarios","text":"PSRI.max_scenarios(ior::AbstractReader)\n\nReturns an Int indicating maximum number of scenarios in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks","page":"Manual","title":"PSRClassesInterface.max_blocks","text":"PSRI.max_blocks(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_current","page":"Manual","title":"PSRClassesInterface.max_blocks_current","text":"PSRI.max_blocks_current(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the cuurent stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_stage","page":"Manual","title":"PSRClassesInterface.max_blocks_stage","text":"PSRI.max_blocks_stage(ior::AbstractReader, t::Integer)\n\nReturns an Int indicating maximum number of blocks in the stage t in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_agents","page":"Manual","title":"PSRClassesInterface.max_agents","text":"PSRI.max_agents(ior::AbstractReader)\n\nReturns an Int indicating maximum number of agents in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.stage_type","page":"Manual","title":"PSRClassesInterface.stage_type","text":"stage_type\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_stage","page":"Manual","title":"PSRClassesInterface.initial_stage","text":"PSRI.initial_stage(ior::AbstractReader)\n\nReturns an Int indicating the initial stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_year","page":"Manual","title":"PSRClassesInterface.initial_year","text":"PSRI.initial_year(ior::AbstractReader)\n\nReturns an Int indicating the initial year in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.data_unit","page":"Manual","title":"PSRClassesInterface.data_unit","text":"PSRI.data_unit(ior::AbstractReader)\n\nReturns a String indicating the unit of the data in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.agent_names","page":"Manual","title":"PSRClassesInterface.agent_names","text":"PSRI.agent_names(ior::AbstractReader)\n\nReturns a Vector{String} with the agent names in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-entire-file","page":"Manual","title":"Read entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.file_to_array\nPSRClassesInterface.file_to_array_and_header","category":"page"},{"location":"manual/#PSRClassesInterface.file_to_array","page":"Manual","title":"PSRClassesInterface.file_to_array","text":"PSRI.file_to_array(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.file_to_array_and_header","page":"Manual","title":"PSRClassesInterface.file_to_array_and_header","text":"PSRI.file_to_array_and_header(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array and header\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-registry","page":"Manual","title":"Read registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.current_stage\nPSRClassesInterface.current_scenario\nPSRClassesInterface.current_block\nPSRClassesInterface.goto\nPSRClassesInterface.next_registry","category":"page"},{"location":"manual/#PSRClassesInterface.current_stage","page":"Manual","title":"PSRClassesInterface.current_stage","text":"PSRI.current_stage(ior::AbstractReader)\n\nReturns an Int indicating the current stage in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_scenario","page":"Manual","title":"PSRClassesInterface.current_scenario","text":"PSRI.current_scenario(ior::AbstractReader)\n\nReturns an Int indicating the current scenarios in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_block","page":"Manual","title":"PSRClassesInterface.current_block","text":"PSRI.current_block(ior::AbstractReader)\n\nReturns an Int indicating the current block in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.goto","page":"Manual","title":"PSRClassesInterface.goto","text":"PSRI.goto(\n    ior::AbstractReader, \n    t::Integer, \n    s::Integer = 1, \n    b::Integer = 1\n)\n\nGoes to the registry of the stage t, scenario s and block b.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.next_registry","page":"Manual","title":"PSRClassesInterface.next_registry","text":"PSRI.next_registry(ior::AbstractReader)\n\nGoes to the next registry on the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#File-conversion","page":"Manual","title":"File conversion","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.convert_file\nPSRClassesInterface.add_reader!","category":"page"},{"location":"manual/#PSRClassesInterface.convert_file","page":"Manual","title":"PSRClassesInterface.convert_file","text":"convert_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.add_reader!","page":"Manual","title":"PSRClassesInterface.add_reader!","text":"add_reader!\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reader-mapper","page":"Manual","title":"Reader mapper","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.ReaderMapper\nPSRClassesInterface.add_reader!\nPSRClassesInterface.goto\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.ReaderMapper","page":"Manual","title":"PSRClassesInterface.ReaderMapper","text":"ReaderMapper{T}\n\n\n\n\n\n","category":"type"},{"location":"manual/#Modification-API","page":"Manual","title":"Modification API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.create_study\nPSRClassesInterface.create_element!\nPSRClassesInterface.set_parm!\nPSRClassesInterface.set_vector!\nPSRClassesInterface.set_series!\nPSRClassesInterface.write_data\nPSRClassesInterface.set_related!\nPSRClassesInterface.set_vector_related!","category":"page"},{"location":"manual/#PSRClassesInterface.create_study","page":"Manual","title":"PSRClassesInterface.create_study","text":"create_study(::AbstractStudyInterface; kwargs...)\n\nReturns the Data object of a new study.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.create_element!","page":"Manual","title":"PSRClassesInterface.create_element!","text":"create_element!(\n    data::Data,\n    collection::String,\n    ps::Pair{String,<:Any};\n    default::Union{Dict{String,Any},Nothing} = nothing\n)\n\nCreates a new instance of the given collection and returns its index.\n\nExample:\n\nindex = PSRI.create_element!(data, \"PSRClass\")\n\nPSRI.set_parm!(data, \"PSRClass\", index, \"PSRAttr\", value)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_parm!","page":"Manual","title":"PSRClassesInterface.set_parm!","text":"set_parm!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    value::T,\n) where {T <: MainTypes}\n\nDefines the value of a scalar parameter.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector!","page":"Manual","title":"PSRClassesInterface.set_vector!","text":"function set_vector!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Int,\n    buffer::Vector{T}\n) where {T<:MainTypes}\n\nUpdates a data vector according to the given buffer. Note: Modifying current vector length is not allowed: use set_series! instead.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_series!","page":"Manual","title":"PSRClassesInterface.set_series!","text":"function set_series!(\n    data::Data,\n    collection::String,\n    index_attr::String,\n    index::Int,\n    buffer::Dict{String,Vector}\n)\n\nUpdates serial (indexed) data. All columns must be the same as before. The series length is allowed to be changed, but all vectors in the new series must have equal length.\n\njulia> series = Dict{String, Vector}(\n         \"GerMin\" => [0.0, 1.0],\n         \"GerMax\" => [888.0, 777.0],\n         \"NGas\" => [nothing, nothing],\n         \"IH\" => [0.0, 0.0],\n         \"CoefE\" => [1.0, 2.0],\n         \"PotInst\" => [888.0, 777.0],\n         \"ICP\" => [0.0, 0.0],\n         \"Data\" => [\"1900-01-01\", \"1900-01-02\"],\n         \"Existing\" => [0, 0],\n         \"sfal\" => [0, 1],\n         \"NAdF\" => [0, 0],\n         \"Unidades\" => [1, 1],\n         \"StartUp\" => [0.0, 2.0]\n       );\n\njulia> PSRI.set_series!(data, \"PSRThermalPlant\", 1, \"Data\", series)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.write_data","page":"Manual","title":"PSRClassesInterface.write_data","text":"write_data(data::Data, path::String)\n\nWrites data to file in JSON format.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_related!","page":"Manual","title":"PSRClassesInterface.set_related!","text":"set_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Integer;\n    relation_type = RELATION_1_TO_1,\n)\n\nSets the element source_index from collection source to be related to the element target_index from collection target in the scalar relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector_related!","page":"Manual","title":"PSRClassesInterface.set_vector_related!","text":"set_vector_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Vector{<:Integer};\n    relation_type = RELATION_1_TO_N,\n)\n\nSets the element source_index from collection source to be related to the elements in target_index from collection target in the vector relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"examples/graf_files/#Graf-Files-and-Time-Series","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"","category":"section"},{"location":"examples/graf_files/#Time-Series","page":"Graf Files and Time Series","title":"Time Series","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Some attributes in a Study represent a time series indexed by another attribute. Here we will be setting a time series for the attribute EmissionCost, from PSRGasEmission, which is indexed by DateEmissionCost.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"First we create a Dict with EmissionCost and DateEmissionCost data.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using Dates\n\nseries = Dict{String,Vector}(\n    \"DateEmissionCost\" => [\n        Dates.Date(\"1900-01-01\"),\n        Dates.Date(\"2013-01-01\"),\n        Dates.Date(\"2013-02-01\")\n    ],\n    \"EmissionCost\" => [0.0,3.0,3.0]\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Then, we save the time series to the study using the function PSRI.set_series!. Notice that when we are saving this time series, we are specifying the element from the collection that has this series, using its index.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"temp_path = joinpath(tempdir(), \"PSRI\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(), data_path = temp_path)\n\nPSRI.create_element!(data, \"PSRGasEmission\")\n\nPSRI.set_series!(\n    data, \n    \"PSRGasEmission\", \n    \"DateEmissionCost\",\n    1, # element index in collection\n    series\n    )","category":"page"},{"location":"examples/graf_files/#Using-a-SeriesTable","page":"Graf Files and Time Series","title":"Using a SeriesTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"We can later retrieve the series for the element in the collection with PSRI.get_series, which will return a SeriesTable object. It can be later displayed as a table in your terminal.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"When using this function, we need the collection, the element index and the attribute that indexes the elements.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using DataFrames\nseries_table = PSRI.get_series(\n    data, \n    \"PSRGasEmission\", \n    \"DateEmissionCost\", \n    1 # element index in collection\n    )\n\nDataFrame(series_table)","category":"page"},{"location":"examples/graf_files/#Graf-files","page":"Graf Files and Time Series","title":"Graf files","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"The data relative to a Study is usually stored in a JSON file, where an attribute can have its data indexed by time intervals, as presented earlier.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"However, when a time series attribute is multidimensional, it can be too large to be stored in a JSON. For these cases, we save the data in a separate file. We will refer to such file as Graf file. When an attribute has its information in a Graf file, there's an entry in the regular JSON file specifying it. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In the following example, each PSRDemand object will have its attribute Duracao data associated with a time series, saved in the files duracao.hdr and duracao.bin. Objects are distinguished by the parmid attribute, which in this case has the AVId value of each PSRDemand element. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file stores the values of an attribute for every element in a collection. So for this example, all values for the attribute Duracao will be store in the Graf file.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"\"PSRGasEmission\": [\n    {\n        \"AVId\": \"Agent 1\"\n        \"name\": \"psr_name\"\n    },\n    {\n        \"AVId\": \"Agent 2\"\n        \"name\": \"psr_name2\"\n    },\n    {\n        \"AVId\": \"Agent 3\"\n        \"name\": \"psr_name3\"\n    }\n],\n\"GrafScenarios\": [\n    {\n        \"classname\": \"PSRDemand\",\n        \"parmid\": \"AVId\",\n        \"vector\": \"Duracao\",\n        \"binary\": [ \"duracao.hdr\", \"duracao.bin\" ]\n    }\n]","category":"page"},{"location":"examples/graf_files/#Graf-file-format","page":"Graf Files and Time Series","title":"Graf file format","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file composed of a header and a table with the following elements:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Stage \nScenario \nBlock\nAgents (one entry for each agent)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Each agent represents an element from the collection the graf file is linked to.","category":"page"},{"location":"examples/graf_files/#Visual-example-of-a-graf-file","page":"Graf Files and Time Series","title":"Visual example of a graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Using the previous example with PSRDemand objects, the Duracao for each object will be displayed in the Agents columns, that will take the name of the AVId attribute, resulting on the following:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Stg Sce Block Agent 1 Agent 2 Agent 3\n1 1 1 1.0 5.0 10.0\n1 1 2 1.5 6.5 11.5\n1 1 3 2.0 7.0 12.0\n... ... ... ... ... ...","category":"page"},{"location":"examples/graf_files/#Graf-Header","page":"Graf Files and Time Series","title":"Graf Header","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file header contains data about the time series contents. Some important information are whether the time series varies per block and/or per Scenario, the number of agents, the unit of measurement and on which stage it should start. ","category":"page"},{"location":"examples/graf_files/#Writing-a-time-series-into-a-Graf-file","page":"Graf Files and Time Series","title":"Writing a time series into a Graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In this example we will demonstrate how to save a time series into a csv or binary file.  First, we create a random array which has the data for a time series:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n#Creates dummy data\nn_blocks = 3\nn_scenarios = 1\nn_stages = 1\nn_agents = 1\n\ntime_series_data = rand(Float64, n_agents, n_blocks, n_scenarios, n_stages)\n\nnothing #hide","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"There are two ways of saving the data to a file, save the data in the file directly or iteratively. To save the data directly use the function PSRI.array_to_file by calling:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"FILE_PATH = joinpath(tempdir(), \"example\")\n\nPSRI.array_to_file(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    time_series_data,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"H\";\n    initial_stage = 3,\n    initial_year = 2006,\n)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To save the data iteractively use the function PSRI.open to create an PSRI.AbstractWriter. Save the data of each registry to the file using the function PSRI.write_registry and then close the data stream calling the function PSRI.close.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"iow = PSRI.open(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    blocks = n_blocks,\n    scenarios = n_scenarios,\n    stages = n_stages,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"H\",\n    initial_stage = 1,\n    initial_year = 2006,\n)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.write_registry(\n        iow,\n        time_series_data[:, block, scenario, stage],\n        stage,\n        scenario,\n        block\n    )\nend\n\nPSRI.close(iow)","category":"page"},{"location":"examples/graf_files/#Reading-a-time-series-from-a-graf-file","page":"Graf Files and Time Series","title":"Reading a time series from a graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A similar logic can be used to read the data from a file. You can read it directly or iteratively. To read the data directly use the function PSRI.file_to_array or PSRI.file_to_array_and_header","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n\n@assert all(isapprox.(data_from_file, time_series_data, atol=1E-7))\n\ndata_from_file_and_header, header = PSRI.file_to_array_and_header(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n@assert all(isapprox.(data_from_file_and_header, time_series_data, atol=1E-7))","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To choose the agents order set use_header to true and label the agents in header.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=true,\n        header=[\"Agent 5\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 1\"]\n    )\n@assert all(isapprox.(data_from_file[1, :, :, :], time_series_data[end, :, :, :], atol=1E-7))\n@assert all(isapprox.(data_from_file[end, :, :, :], time_series_data[1, :, :, :], atol=1E-7))","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To read the data iteractively use the function PSRI.open to create an PSRI.AbstractReader and read each registry iteratively. At the end you should close the PSRI.AbstractReader by calling PSRI.close","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"ior = PSRI.open(\n    PSRI.OpenBinary.Reader, \n    FILE_PATH;\n    use_header = false\n)\n\ndata_from_file = zeros(n_agents, n_blocks, n_scenarios, n_stages)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    data_from_file[:, block, scenario, stage] = ior.data\n    PSRI.next_registry(ior)\nend\n\nPSRI.close(ior)\n","category":"page"},{"location":"examples/graf_files/#Using-Graf-files-in-a-study","page":"Graf Files and Time Series","title":"Using Graf files in a study","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"As presented earlier, an attribute for a collection can have its data stored in a Graf file, all that being specified in the GrafScenarios entry of the study JSON. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"If you have a Graf file that should be linked to a study, you can use the function PSRI.link_series_to_file to do so.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 1\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 2\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 3\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 4\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 5\")\n\nPSRI.link_series_to_file(\n        data, \n        \"PSRDemand\", \n        \"Duracao\", \n        \"AVId\",\n        FILE_PATH\n    )","category":"page"},{"location":"examples/graf_files/#Using-a-GrafTable","page":"Graf Files and Time Series","title":"Using a GrafTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"We can retrieve the data stored in a Graf file using the PSRI.get_graf_series function. This function returns a GrafTable object. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"When using this function, we need the collection and its attribute that is linked to a Graf file.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"graf_table = PSRI.get_graf_series(\n        data,\n        \"PSRDemand\",\n        \"Duracao\";\n        use_header = false\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Once you have a GrafTable object, you can display it as a table in your terminal","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using DataFrames\n\nDataFrame(graf_table)","category":"page"},{"location":"examples/graf_files/#Vector-from-graf-file","page":"Graf Files and Time Series","title":"Vector from graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"You can get a vector that corresponds to a row in a Graf file with the values for the agents correspoding to the current stage, scenario and block.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"For that, we will have to use the function PSRI.mapped_vector. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"vec = PSRI.mapped_vector(\n        data, \n        \"PSRDemand\", \n        \"Duracao\",\n        Float64\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"The parameters that were used to retrieve the row value in the Graf table can be changed with the following functions:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.go_to_stage\nPSRI.go_to_scenario\nPSRI.go_to_block","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"These methods don't automatically update the vector. For that, we use the function PSRI.update_vectors!, which update all vectors from our Study.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.update_vectors!(data)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"However, it might be interesting to update only one or a group of vectors. To be able to do that, we will have to set a filter tag when we create them.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"vec2 = PSRI.mapped_vector(\n        data, \n        \"PSRDemand\", \n        \"Duracao\",\n        Float64,\n        filters = [\"test_filter\"]\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Then, when we run:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.update_vectors!(data, \"test_filter\")","category":"page"},{"location":"examples/graf_files/#Comparison-between-a-GrafTable-and-a-SeriesTable","page":"Graf Files and Time Series","title":"Comparison between a GrafTable and a SeriesTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In this section we have introduced some new concepts about table-like types. That being said, let's review the main differences between GrafTables and SeriesTables:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"SeriesTable\nIs linked to a single element from a collection\nIt can have time series of different attributes that are indexed to a single attribute (all belonging to the same element)\nGrafTable\nIs linked to the whole collection. So for an attribute, every element in the collection will have an entry in the graf file\nIt has the time series for only one attribute","category":"page"},{"location":"#PSRClassesInterface-Documentation","page":"Home","title":"PSRClassesInterface Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository to read and write open-source formats for PSR models.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered so you can simply add it using Julia's Pkg manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PSRClassesInterface","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide","category":"page"}]
}
