var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Writing-and-reading-a-time-series-into-a-file","page":"Examples","title":"Writing and reading a time series into a file","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will demonstrate how to save a time series into a csv or binary file.  The first step is to obtain the data that you wish to save","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n#Creates dummy data\nn_blocks = 2\nn_scenarios = 3\nn_stages = 4\nn_agents = 5\n\ntime_series_data = rand(Float64, n_agents, n_blocks, n_scenarios, n_stages)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are two ways of saving the data to a file, save the data in the file directly or iteratively. To save the data directly use the function PSRI.array_to_file by calling:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FILE_PATH = joinpath(\".\", \"example\")\n\nPSRI.array_to_file(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    time_series_data,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"MW\";\n    initial_stage = 3,\n    initial_year = 2006,\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To save the data iteractively use the function PSRI.open to create an PSRI.AbstractWriter. Save the data of each registry to the file using the function PSRI.write_registry and then close the data stream calling the function PSRI.close.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"iow = PSRI.open(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    blocks = n_blocks,\n    scenarios = n_scenarios,\n    stages = n_stages,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"MW\",\n    initial_stage = 1,\n    initial_year = 2006,\n)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.write_registry(\n        iow,\n        time_series_data[:, block, scenario, stage],\n        stage,\n        scenario,\n        block\n    )\nend\n\nPSRI.close(iow)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A similar logic can be used to read the data from a file. You can read it directly or iteratively. To read the data directly use the function PSRI.file_to_array or PSRI.file_to_array_and_header","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n\n@assert all(isapprox.(data_from_file, time_series_data, atol=1E-7))\n\ndata_from_file_and_header, header = PSRI.file_to_array_and_header(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n@assert all(isapprox.(data_from_file_and_header, time_series_data, atol=1E-7))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To read the data iteractively use the function PSRI.open to create an PSRI.AbstractReader and read each registry iteratively. At the end you should close the PSRI.AbstractReader by calling PSRI.close","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ior = PSRI.open(\n    PSRI.OpenBinary.Reader, \n    FILE_PATH;\n    use_header = false\n)\n\ndata_from_file = zeros(n_agents, n_blocks, n_scenarios, n_stages)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.next_registry(ior)\n    data_from_file[:, block, scenario, stage] = ior.data\nend\n\nPSRI.close(ior)\n\nrm(FILE_PATH; force = true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To choose the agents order use use_header and header","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=true,\n        header=[\"Agent 5\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 1\"]\n    )\n@assert all(isapprox.(data_from_file[1, :, :, :], time_series_data[end, :, :, :], atol=1E-7))\n@assert all(isapprox.(data_from_file[end, :, :, :], time_series_data[1, :, :, :], atol=1E-7))","category":"page"},{"location":"examples/#Reading-configuration-parameters","page":"Examples","title":"Reading configuration parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Most cases have configuration parameters such as the maximum number of iterations, the discount rate, the deficit cost etc. The function PSRI.configuration_parameter reads all the parameters from the cases.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CONFIGS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CONFIGS\n)\n\nPSRI.configuration_parameter(data, \"TaxaDesconto\", 0.0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])","category":"page"},{"location":"examples/#Reading-basic-thermal-generator-parameters","page":"Examples","title":"Reading basic thermal generator parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will map parameters of thermal generators at each stage of the study to a struct. Suppose in this case that our thermal generators has the following attributes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base.@kwdef mutable struct ThermalGenerators\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    generation_capacities::Vector{Float64} = Float64[]\n    therm2sys::Vector{Int32} = Int32[]\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first thing we must do is to initialize the reading procedure with the following commands:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THERMALS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso0\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THERMALS\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can initialize the struct with the parameters of the first stage using the function PSRI.mapped_vector","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"therm_gen = ThermalGenerators()\ntherm_gen.names = PSRI.get_name(data, \"PSRThermalPlant\")\ntherm_gen.codes = PSRI.get_code(data, \"PSRThermalPlant\")\ntherm_gen.generation_capacities = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\ntherm_gen.therm2sys = PSRI.get_map(data, \"PSRThermalPlant\", \"PSRSystem\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And afterwards we can update the parameters for each stage as follows.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"for stage in 1:PSRI.total_stages(data)\n    PSRI.go_to_stage(data, stage)\n    PSRI.update_vectors!(data)\n    println(\"Thermal generator 2 generation capacity at stage $stage $(therm_gen.generation_capacities[2])\")\nend","category":"page"},{"location":"examples/#Reading-basic-battery-parameters","page":"Examples","title":"Reading basic battery parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is very similar to \"Reading basic thermal generator parameters\", but it is necessary to be cautious about the difference between elements. For instance, batteries have different parameters than thermal generators, therefore, our data structure must be defined accordingly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base.@kwdef mutable struct Batteries\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    charge_eff::Vector{Float64} = Float64[]\n    bat2sys::Vector{Int32} = Int32[]\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Stardard proceadure of reading data from file:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BATTERIES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And now the struct may be instantiated by setting its appropriate parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"batteries = Batteries()\nbatteries.names = PSRI.get_name(data, \"PSRBattery\")\nbatteries.codes = PSRI.get_code(data, \"PSRBattery\")\nbatteries.charge_eff = PSRI.mapped_vector(data, \"PSRBattery\", \"ChargeEffic\", Float64)\nbatteries.bat2sys = PSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")","category":"page"},{"location":"examples/#Determining-subsystem-from-a-certain-hydro-plant","page":"Examples","title":"Determining subsystem from a certain hydro plant","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will demonstrate how to make a simple use of a relationship map. That will be achieved by determining a subsystem from a certain hydro plant through its parameters. The program will initiate by the standard reading procedure:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_GAUGING = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso2\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_GAUGING\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, the maps between hydroplants and systems is retrieved by the get_map method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hyd2sys = PSRI.get_map(data, \"PSRHydroPlant\",\"PSRSystem\")","category":"page"},{"location":"examples/#Determining-buses-from-a-certain-thermal-plant","page":"Examples","title":"Determining buses from a certain thermal plant","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This case consists of a more advanced use of a relationship map. We'll determine which buses are linked to a given target thermal plant, while there is no direct relationship between both. Firstly, the study data is read:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BUS\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Whereas there is no direct link between buses and thermal plants, both are indirectly related through generators. Therefore, we must identify those relationships by calling get_map for each:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"gen2thermal = PSRI.get_map(data, \"PSRGenerator\",\"PSRThermalPlant\")\ngen2bus = PSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we can find which generators are linked to our target thermal plant by the indexes of gen2the:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"target_thermal = 1\ntarget_generator = findall(isequal(target_thermal), gen2thermal)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"target_generator now holds the indexes of generators that are linked to the buses we are trying to identify. With those at hand, the indexes of the buses are easily identifiable by:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"targetBus = gen2bus[target_generator]","category":"page"},{"location":"examples/#Determining-elasticity-and-value-of-demands","page":"Examples","title":"Determining elasticity and value of demands","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will read demand segments, obtain the value of demands, discover wheter each demand is elastic or inelastic, and then obtain the sums of demands by elasticity. The first step is to read the study data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_DEM = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_DEM\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Whereas the demand varies according to the stage, we must specify the stage by calling go_to_stage:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"target_stage = 1\nPSRI.go_to_stage(data,target_stage)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we can read the demand segments and the map between demands and demand segments, and then obtain the value of each demand:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"dem_seg = PSRI.mapped_vector(data, \"PSRDemandSegment\", \"Demanda\", Float64, \"block\")\n\nseg2dem = PSRI.get_map(data, \"PSRDemandSegment\", \"PSRDemand\", relation_type = PSRI.RELATION_1_TO_1)\n\ndem_size = PSRI.max_elements(data, \"PSRDemand\")\n\ndemand_values = zeros(dem_size)\n\nfor demand = 1:dem_size\n    demand_values[demand] = sum(dem_seg[i] for i = 1:length(dem_seg) if seg2dem[i] == demand)\nend\n\ndemand_values","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can discover the elasticity of each demand by calling get_parms with the parameter Elastico:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"demands_elasticity = PSRI.get_parms(data, \"PSRDemand\", \"Elastico\", Int32)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If demands_elasticity[i] == 0 it means that the demand at index i is inelastic, and elastic if demands_elasticity[i] == 1. We can now obtain the total demands of each elasticity:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"total_elastic_demand = 0.0\ntotal_inelastic_demand = 0.0\n\nfor i = 1:dem_size\n    if demands_elasticity[i] == 0\n        total_inelastic_demand += demand_values[i]\n    else\n        total_elastic_demand += demand_values[i]\n    end\nend","category":"page"},{"location":"examples/#Determining-demands-values-of-each-bus","page":"Examples","title":"Determining demands values of each bus","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we have the values of the demands, we can obtain the values of demand for each bus.  Each demand has a set of loads, which define how much of this demand corresponds to each bus.  We can begin by reading the loads and its relations with demands and buses:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"loads = PSRI.mapped_vector(data, \"PSRLoad\", \"P\", Float64, \"block\")\nlod2dem = PSRI.get_map(data, \"PSRLoad\", \"PSRDemand\", relation_type = PSRI.RELATION_1_TO_1)\nlod2bus = PSRI.get_map(data, \"PSRLoad\", \"PSRBus\", relation_type = PSRI.RELATION_1_TO_1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The values of the loads are weights in a kind of a weighted arithmetic mean of the buses for each demand. But the loads of each demand don't add up to 1, so they need to be normalized to represent fractions of the total:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"total_lod_bydem = zeros(dem_size)\nlod_size = PSRI.max_elements(data, \"PSRLoad\")\n\nfor i in 1:lod_size\n    total_lod_bydem[lod2dem[i]] += loads[i]\nend\n\nfor i in 1:lod_size\n    if total_lod_bydem[lod2dem[i]] > 0.0\n        loads[i] = loads[i]/total_lod_bydem[lod2dem[i]]\n    else\n        loads[i] = 0.0\n    end\nend\n\nloads","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we know the fraction of each demand that corresponds to each bus, and can easily define the total demand by bus:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\n\ndem_bybus = zeros(bus_size)\n\nfor lod = 1:lod_size\n    fraction = loads[lod]\n    dem = lod2dem[lod]\n    bus = lod2bus[lod] \n    dem_bybus[bus] += demand_values[dem]*fraction\nend\n\ndem_bybus","category":"page"},{"location":"examples/#Determining-which-buses-are-connected-by-each-circuit","page":"Examples","title":"Determining which buses are connected by each circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each circuit connects two buses, it starts from a bus and goes to another. In this example we'll discover these buses for each circuit and then we'll build an incidence matrix of buses by circuits. The first step is to read the data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CIR_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CIR_BUS\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we get from which bus each circuit starts and which bus it goes to with get_map:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cir2bus_to = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\"; relation_type = PSRI.RELATION_TO)\ncir2bus_from = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\"; relation_type = PSRI.RELATION_FROM)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can build the incidence matrix. Each row corresponds to a circuit and each column corresponds to a bus. The element at the index (i,j) is -1 if the circuit i starts from the bus j, 1 if it goes to this bus, and 0 if they both have no relation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\ncir_size = PSRI.max_elements(data, \"PSRSerie\")\nincidence_matrix = zeros(Float64, cir_size, bus_size)\nfor cir = 1:cir_size\n    incidence_matrix[cir, cir2bus_from[cir]] = -1.0\n    incidence_matrix[cir, cir2bus_to[cir]] = 1.0\nend\nincidence_matrix","category":"page"},{"location":"examples/#Calculating-the-energy-prices-of-each-thermal-plant","page":"Examples","title":"Calculating the energy prices of each thermal plant","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The energy prices in a thermal plant deppends on the  the price of the fuel used, the specific consumption of this fuel and Operation and Maintenance cost. Again, we begin by reading the data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THER_PRICES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"caso1\")\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THER_PRICES\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We discover the necessary infos of the thermal plants indirectly through PSRFuelConsumption:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fuelcons2ther = PSRI.get_map(data,\"PSRFuelConsumption\", \"PSRThermalPlant\"; relation_type = PSRI.RELATION_1_TO_1)\n\nther_size = PSRI.max_elements(data, \"PSRThermalPlant\")\nfuelcons_size = PSRI.max_elements(data, \"PSRFuelConsumption\")\nther2fuelcons = [[fc for fc = 1:fuelcons_size if fuelcons2ther[fc] == t] for t = 1:ther_size]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we get the O&M cost, the specific consumption and the relation with fuels of our fuels consumptions. Then we get the cost of each fuel. After calling mapped_vector we must call update_vectors!.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"om_cost = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"O&MCost\", Float64)\nspec_consum = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"CEsp\", Float64, \"segment\", \"block\")\nfuelcons2fuel = PSRI.get_map(data, \"PSRFuelConsumption\", \"PSRFuel\"; relation_type = PSRI.RELATION_1_TO_1)\nfuel_cost = PSRI.mapped_vector(data, \"PSRFuel\", \"Custo\", Float64)\n\nPSRI.update_vectors!(data)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can calculate the price of the energy unity of each fuel consumption for each thermal plant:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ther_prices = [zeros(0) for _ = 1:ther_size]\nfor ther = 1:ther_size\n    n_fuelcons = length(ther2fuelcons[ther])\n    prices = zeros(n_fuelcons)\n    for i = 1:n_fuelcons\n        fuelcons = ther2fuelcons[ther][i]\n        fuel = fuelcons2fuel[fuelcons]\n        prices[i] = om_cost[fuelcons] + spec_consum[fuelcons]*fuel_cost[fuel]\n    end\n    ther_prices[ther] = prices\nend\nther_prices","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PSRClassesInterface module provides interfaces to access data structured by PSR to be used in its models. Currently there are two main interfaces. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface for studies. This interface is designed to read parameters from the files, some examples are deficit costs, fuel costs, currency, storage capacity etc.\nThe interface for reading and writing time series data. Time series data in the context of most studies have 4 dimensions (agents, stages, scenarios and blocks). Since studies of renewables with multiple agents, scenarios and stages can get quite big, we have designed different formats that are optimized to some objective (human readability, size, fast reading and writing, etc.).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both interfaces are defined as a set of methods that need to be implemented to make a different file format work. In this manual we will describe the abstract methods and give concrete examples of code to perform the work needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When using the PSRClassesInterface package in your codebase we strongly advise you to create a constant PSRI to keep the code concise and explicitly declare that a certain function came from PSRClassesInterface. This can be done by adding the following code to the top of the code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface","category":"page"},{"location":"manual/#Initialize-Study","page":"Manual","title":"Initialize Study","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractData\nPSRClassesInterface.AbstractStudyInterface\nPSRClassesInterface.initialize_study\nPSRClassesInterface.description\nPSRClassesInterface.max_elements","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractData","page":"Manual","title":"PSRClassesInterface.AbstractData","text":"AbstractData\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.AbstractStudyInterface","page":"Manual","title":"PSRClassesInterface.AbstractStudyInterface","text":"AbstractStudyInterface\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.initialize_study","page":"Manual","title":"PSRClassesInterface.initialize_study","text":"initialize_study(::AbstractStudyInterface; kwargs...)\n\nInitialize all data structures of the study.\n\nnote: Differences between the OpenInterface and ClassicInterface\nEach study interface has its own set of kwargs... The easiest way to inspect the current available options is searching for this function on the Github repo of the desired interface.\n\nExample:\n\ndata = PSRI.initialize_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.description","page":"Manual","title":"PSRClassesInterface.description","text":"description(data::AbstractData)\n\nReturns the study description if available.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_elements","page":"Manual","title":"PSRClassesInterface.max_elements","text":"max_elements(data::AbstractData, collection::String)\n\nReturns an Int32 with the maximum number of elements for a given collection.\n\nExample:\n\nPSRI.max_elements(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-dimensions","page":"Manual","title":"Study dimensions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.StageType\nPSRClassesInterface.total_stages\nPSRClassesInterface.total_scenarios\nPSRClassesInterface.total_blocks\nPSRClassesInterface.total_openings\nPSRClassesInterface.total_stages_per_year","category":"page"},{"location":"manual/#PSRClassesInterface.StageType","page":"Manual","title":"PSRClassesInterface.StageType","text":"PSRI.StageType\n\nPossible stage types used in for reading and writing time series files.\n\nThe current possible stage types are:\n\nSTAGE_UNKNOWN\nSTAGE_WEEK\nSTAGE_MONTH\nSTAGE_3MONTHS\nSTAGE_DAY\nSTAGE_13MONTHS\nSTAGE_2MONTHS\nSTAGE_4MONTHS\nSTAGE_6MONTHS\nSTAGE_YEAR\nSTAGE_DECADE\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.total_stages","page":"Manual","title":"PSRClassesInterface.total_stages","text":"total_stages(data::AbstractData)\n\nReturns the total number of stages of the case.\n\nExample:\n\nPSRI.total_stages(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_scenarios","page":"Manual","title":"PSRClassesInterface.total_scenarios","text":"total_scenarios(data::AbstractData)\n\nReturns the total number of scenarios of the case.\n\nExample:\n\nPSRI.total_scenarios(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_blocks","page":"Manual","title":"PSRClassesInterface.total_blocks","text":"total_blocks(data::AbstractData)\n\nReturns the total number of blocks of the case.\n\nExample:\n\nPSRI.total_blocks(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_openings","page":"Manual","title":"PSRClassesInterface.total_openings","text":"total_openings(data::AbstractData)\n\nReturns the total number of openings of the case.\n\nExample:\n\nPSRI.total_openings(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_stages_per_year","page":"Manual","title":"PSRClassesInterface.total_stages_per_year","text":"total_stages_per_year(data::AbstractData)\n\nReturns the total number of stages per year of the case.\n\nExample:\n\nPSRI.total_stages_per_year(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-duration-and-blocking","page":"Manual","title":"Study duration and blocking","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.BlockDurationMode\nPSRClassesInterface.stage_duration\nPSRClassesInterface.block_duration\nPSRClassesInterface.block_from_stage_hour","category":"page"},{"location":"manual/#Read-Scalar-Attributes","page":"Manual","title":"Read Scalar Attributes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.configuration_parameter\nPSRClassesInterface.get_code\nPSRClassesInterface.get_name\nPSRClassesInterface.get_parm\nPSRClassesInterface.get_parm_1d\nPSRClassesInterface.get_parms\nPSRClassesInterface.get_parms_1d","category":"page"},{"location":"manual/#PSRClassesInterface.configuration_parameter","page":"Manual","title":"PSRClassesInterface.configuration_parameter","text":"configuration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::T\n) where T <: MainTypes\n\nReturns the required configuration parameter from the case. If the parameter is not registered returns the default value.\n\nconfiguration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::Vector{T},\n) where T <: MainTypes\n\nReturns the rquired configuration parameters from the case that are vectors that are vectors. If the parameter is not registered returns the default value.\n\nExamples:\n\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\n\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_code","page":"Manual","title":"PSRClassesInterface.get_code","text":"get_code(data::AbstractData, collection::String)\n\nReturns a Vector{Int32} containing the code of each element in collection.\n\nExample:\n\nPSRI.get_code(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_name","page":"Manual","title":"PSRClassesInterface.get_name","text":"get_name(data::AbstractData, collection::String)\n\nReturns a Vector{String} containing the name of each element in collection.\n\nExample:\n\nPSRI.get_name(data, \"PSRThermalPlant\")\nPSRI.get_name(data, \"PSRGaugingStation\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm","page":"Manual","title":"PSRClassesInterface.get_parm","text":"get_parm(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm(data, \"PSRBattery\", \"Einic\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"ChargeRamp\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"DischargeRamp\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm_1d","page":"Manual","title":"PSRClassesInterface.get_parm_1d","text":"get_parm_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64, 1)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms","page":"Manual","title":"PSRClassesInterface.get_parms","text":"get_parms(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    check_type::Bool = true,\n    check_parm::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parms(data, \"PSRBattery\", \"Einic\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"ChargeRamp\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"DischargeRamp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms_1d","page":"Manual","title":"PSRClassesInterface.get_parms_1d","text":"get_parms_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    check_type::Bool = true,\n    check_parm::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-Vector-Attributes","page":"Manual","title":"Read Vector Attributes","text":"","category":"section"},{"location":"manual/#Time-controller","page":"Manual","title":"Time controller","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.mapped_vector\nPSRClassesInterface.go_to_stage\nPSRClassesInterface.go_to_dimension\nPSRClassesInterface.update_vectors!","category":"page"},{"location":"manual/#PSRClassesInterface.mapped_vector","page":"Manual","title":"PSRClassesInterface.mapped_vector","text":"mapped_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n    dim1::String=\"\",\n    dim2::String=\"\";\n    ignore::Bool=false,\n    map_key = collection, # reference for PSRMap pointer, if empty use class name\n    filters = String[], # for calling just within a subset instead of the full call\n) where T\n\nMaps a Vector{T} containing the elements in collection to a vector in julia. When the function update_vectors! is called the elements of the vector will be updated to the according elements registered at the current data.time_controller.\n\nExample:\n\nexisting = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"Existing\", Int32)\npot_inst = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\n\nFor more information please read the example Reading basic thermal generator parameters\n\nnote: Differences between the OpenInterface and ClassicInterface\nWhen using mapped_vector in the OpenInterface mode the vector will be mapped with the correct values at first hand. When using mapped_vector in the ClassicInterface mode you should call update_vectors! to get the good values for the collection, otherwise you might only get a vector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_stage","page":"Manual","title":"PSRClassesInterface.go_to_stage","text":"go_to_stage(data::AbstractData, stage::Integer)\n\nGoes to the stage in the data time controller.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_dimension","page":"Manual","title":"PSRClassesInterface.go_to_dimension","text":"go_to_dimension(data::AbstractData, name::String, value::Integer)\n\nMoves time controller reference of vectors indexed by dimension name to the index value.\n\nExample:\n\ncesp = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"CEsp\", Float64, \"segment\", \"block\")\n\nPSRI.go_to_stage(data, 1)\n\nPSRI.go_to_dimension(data, \"segment\", 1)\nPSRI.go_to_dimension(data, \"block\", 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.update_vectors!","page":"Manual","title":"PSRClassesInterface.update_vectors!","text":"update_vectors!(data::AbstractData)\n\nUpdate all mapped vectors according to the time controller inside data.\n\nupdate_vectors!(data::AbstractData, filters::Vector{String})\n\nUpdate filtered classes of mapped vectors according to the time controller inside data.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Direct-access","page":"Manual","title":"Direct access","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_vector\nPSRClassesInterface.get_vector_1d\nPSRClassesInterface.get_vector_2d\nPSRClassesInterface.get_vectors\nPSRClassesInterface.get_vectors_1d\nPSRClassesInterface.get_vectors_2d\nPSRClassesInterface.get_nonempty_vector\nPSRClassesInterface.get_series","category":"page"},{"location":"manual/#PSRClassesInterface.get_vector","page":"Manual","title":"PSRClassesInterface.get_vector","text":"PSRI.get_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} of entries of the attribute of collection at the element with index index.\n\nExample:\n\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Vazao\", 1, Float64)\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Data\", 1, Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_1d","page":"Manual","title":"PSRClassesInterface.get_vector_1d","text":"PSRI.get_vector_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection at the element with index index. The outer vector contains one entry per index in dimension 1, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_1d(data, \"PSRArea\", \"Export\", 1, Float64)\nPSRI.get_vector_1d(data, \"PSRLoad\", \"P\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_2d","page":"Manual","title":"PSRClassesInterface.get_vector_2d","text":"PSRI.get_vector_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Matrix{Vector{T}} of entries of the attribute of collection at the element with index index. The outer matrix contains one entry per index in dimension 1 and dimension 2, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_2d(data, \"PSRThermalPlant\", \"CEsp\", 1, Float64)\nPSRI.get_vector_2d(data, \"PSRFuelConsumption\", \"CEsp\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors","page":"Manual","title":"PSRClassesInterface.get_vectors","text":"PSRI.get_vectors(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection.\n\nExample:\n\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Vazao\", Float64)\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Data\", Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_1d","page":"Manual","title":"PSRClassesInterface.get_vectors_1d","text":"PSRI.get_vectors_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Vector{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the 2 inner vectors see get_vector_1d.\n\nExample:\n\nPSRI.get_vectors_1d(data, \"PSRArea\", \"Export\", Float64)\nPSRI.get_vectors_1d(data, \"PSRLoad\", \"P\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_2d","page":"Manual","title":"PSRClassesInterface.get_vectors_2d","text":"PSRI.get_vectors_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Matrix{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the Matrix{Vector{T}} see get_vector_2d.\n\nExample:\n\nPSRI.get_vectors_2d(data, \"PSRThermalPlant\", \"CEsp\", Float64)\nPSRI.get_vectors_2d(data, \"PSRFuelConsumption\", \"CEsp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_nonempty_vector","page":"Manual","title":"PSRClassesInterface.get_nonempty_vector","text":"get_nonempty_vector(\n    data::AbstractData,\n    colllection::String,\n    attribute::String,\n)\n\nReturns a vector of booleans with the number of elements of the collection. true means the vector associated with the given attribute is non-emepty, false means it is empty.\n\nExample:\n\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"ChroGerMin\")\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"SpinningReserve\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_series","page":"Manual","title":"PSRClassesInterface.get_series","text":"function get_series(\n    data::Data,\n    collection::String,\n    indexing_attribute::String,\n    index::Int,\n)\n\nRetrieves the series i.e. Dict{String, Vector} indexed by index_attr.\n\nExample\n\njulia> PSRI.get_series(data, \"PSRThermalPlant\", \"Data\", 1)\nDict{String, Vector} with 13 entries:\n  \"GerMin\"   => [0.0]\n  \"GerMax\"   => [888.0]\n  \"NGas\"     => [nothing]\n  \"IH\"       => [0.0]\n  \"ICP\"      => [0.0]\n  \"Data\"     => [\"1900-01-01\"]\n  \"CoefE\"    => [1.0]\n  \"PotInst\"  => [888.0]\n  \"Existing\" => [0]\n  \"sfal\"     => [0]\n  \"NAdF\"     => [0]\n  \"Unidades\" => [1]\n  \"StartUp\"  => [0.0]\n\n\n\n\n\n","category":"function"},{"location":"manual/#Relations-between-collections","page":"Manual","title":"Relations between collections","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.RelationType\nPSRClassesInterface.is_vector_relation\nPSRClassesInterface.get_map\nPSRClassesInterface.get_vector_map\nPSRClassesInterface.get_reverse_map\nPSRClassesInterface.get_reverse_vector_map\nPSRClassesInterface.get_related\nPSRClassesInterface.get_vector_related","category":"page"},{"location":"manual/#PSRClassesInterface.RelationType","page":"Manual","title":"PSRClassesInterface.RelationType","text":"RelationType\n\nPossible relation types used in mapping function such as get_map, get_reverse_map, etc.\n\nThe current possible relation types are:\n\nRELATION_1_TO_1\nRELATION_1_TO_N\nRELATION_FROM\nRELATION_TO\nRELATION_TURBINE_TO\nRELATION_SPILL_TO\nRELATION_INFILTRATE_TO\nRELATION_STORED_ENERGY_DONWSTREAM\nRELATION_BACKED\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.get_map","page":"Manual","title":"PSRClassesInterface.get_map","text":"get_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    allow_empty::Bool = true,\n    relation_type::RelationType = RELATION_1_TO_1, # type of the direct relation\n)\n\nReturns a Vector{Int32} with the map between collections given a certain RelationType.\n\nExamples:\n\nPSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRThermalPlant\")\n\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_TURBINE_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_SPILL_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_INFILTRATE_TO)\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_STORED_ENERGY_DONWSTREAM)\n\n@test PSRI.get_map(data, \"PSRInterconnection\", \"PSRSystem\", relation_type = PSRI.RELATION_FROM)\n@test PSRI.get_map(data, \"PSRInterconnection\", \"PSRSystem\", relation_type = PSRI.RELATION_TO)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_map","page":"Manual","title":"PSRClassesInterface.get_vector_map","text":"get_vector_map(\n    data::AbstractData,\n    collection_from::String,\n    collection_to::String;\n    relation_type::RelationType = RELATION_1_TO_N,\n)\n\nReturns a Vector{Vector{Int32}} to represent the relation between each element of collection_from to multiple elements of collection_to.\n\nSince multiple relations might be available one might need to specify relation_type.\n\nExample:\n\nPSRI.get_vector_map(data, \"PSRInterconnectionSumData\", \"PSRInterconnection\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRHydroPlant\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRThermalPlant\", relation_type = PSRI.RELATION_BACKED)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_map","page":"Manual","title":"PSRClassesInterface.get_reverse_map","text":"get_reverse_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_1,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Int32} with the relation reversed. Some relations cannot be reversed this way since they are not bijections, in this case use get_reverse_vector_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\nPSRI.get_reverse_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n# which is te reverse of\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n\nPSRI.get_reverse_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_vector_map","page":"Manual","title":"PSRClassesInterface.get_reverse_vector_map","text":"get_reverse_vector_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_N,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Vector{Int32}} with the relation reversed.\n\nSome relations are bijections, in these cases it is also possible to use use get_reverse_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\n# upstream turbining hydros\nPSRI.get_reverse_vector_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", original_relation_type = PSRI.RELATION_TURBINE_TO)\n# which is the reverse of\nPSRI.get_map(data, \"PSRHydroPlant\", \"PSRHydroPlant\", relation_type = PSRI.RELATION_TURBINE_TO)\n\nPSRI.get_reverse_vector_map(data, \"PSRGenerator\", \"PSRBus\", original_relation_type = PSRI.RELATION_1_TO_1)\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_related","page":"Manual","title":"PSRClassesInterface.get_related","text":"get_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_1,\n)\n\nReturns the index of the element in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_related","page":"Manual","title":"PSRClassesInterface.get_vector_related","text":"get_vector_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_N,\n)\n\nReturns the vector of indices of the elements in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reflection","page":"Manual","title":"Reflection","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_attribute_dim1\nPSRClassesInterface.get_attribute_dim2\nPSRClassesInterface.get_collections\nPSRClassesInterface.get_attributes\nPSRClassesInterface.get_attribute_struct\nPSRClassesInterface.get_data_struct\nPSRClassesInterface.Attribute\nPSRClassesInterface.get_attributes_indexed_by\nPSRClassesInterface.get_relations\nPSRClassesInterface.get_attribute_dim","category":"page"},{"location":"manual/#PSRClassesInterface.get_attribute_dim1","page":"Manual","title":"PSRClassesInterface.get_attribute_dim1","text":"get_attribute_dim1(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 1 of attribute from collection at element index. Errors if attribute has zero dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim2","page":"Manual","title":"PSRClassesInterface.get_attribute_dim2","text":"get_attribute_dim2(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 2 of attribute from collection at element index. Errors if attribute has zero or one dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_collections","page":"Manual","title":"PSRClassesInterface.get_collections","text":"get_collections(data::AbstractData)\n\nReturn Vector{String} of valid collections (depends on loaded pmd files).\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attributes","page":"Manual","title":"PSRClassesInterface.get_attributes","text":"get_attributes(data::AbstractData, collection::String)\n\nReturn Vector{String} of valid attributes from collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_struct","page":"Manual","title":"PSRClassesInterface.get_attribute_struct","text":"get_attribute_struct(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n)\n\nReturns a struct of type Attribute with fields:\n\nname::String = attribute name\nis_vector::Bool = true if attribute is a vector (tipically, varies in time)\ntype::DataType = attribute type (tipically: Int32, Float64, String, Dates.Date)\ndim::Int = number of additional dimensions\nindex::String = if a vector represents the indexing vector (might be empty)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_data_struct","page":"Manual","title":"PSRClassesInterface.get_data_struct","text":"get_attribute_struct(data::AbstractData)\n\nReturn a struct of type DataStruct with collection names (strings) as keys and maps from attributes names (string) to attributes data definitions Attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.Attribute","page":"Manual","title":"PSRClassesInterface.Attribute","text":"Attribute\n\nstruct Attribute     name::String     is_vector::Bool     type::DataType     dim::Int     index::String end\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.get_attributes_indexed_by","page":"Manual","title":"PSRClassesInterface.get_attributes_indexed_by","text":"get_attributes_indexed_by(\n    data::AbstractData,\n    collection::String,\n    indexing_attribute::String\n)\n\nReturn Vector{String} of valid vector attributes from collection that are indexed by indexing_attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_relations","page":"Manual","title":"PSRClassesInterface.get_relations","text":"get_relations(data::AbstractData, collection::String)\n\nReturns a Vector{Tuple{String, RelationType}} with relating collection and their relation type associated to collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim","page":"Manual","title":"PSRClassesInterface.get_attribute_dim","text":"get_attribute_dim(attribute_struct::Attribute)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-Graf-files","page":"Manual","title":"Write Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractWriter\nPSRClassesInterface.open\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractWriter","page":"Manual","title":"PSRClassesInterface.AbstractWriter","text":"PSRI.AbstractWriter\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.open","page":"Manual","title":"PSRClassesInterface.open","text":"PSRI.open(::Type{<:AbstractWriter}, path::String; kwargs...)\n\nMethod for opening file and registering time series data. If specified file doesn't exist, the method will create it, otherwise, the previous one will be overwritten. Returns updated AbstractWriter instance. \n\nArguments:\n\nwriter: AbstractWriter instance to be used for opening file.\npath: path to file.\n\nKeyword arguments:\n\nblocks: case's number of blocks.\nscenarios: case's number of scenarios.\nstages: case's number of stages.\nagents: list of element names.\nunit: dimension of the elements' data.\nis_hourly: if data is hourly. If yes, block dimension will be ignored.\nhour_discretization: sub-hour parameter to discretize an hour into minutes.\nname_length: length of element names.\nblock_type: case's type of block.\nscenarios_type: case's type of scenario.\nstage_type: case's type of stage.\ninitial_stage: stage at which to start registry.\ninitial_year: year at which to start registry.\nallow_unsafe_name_length: allow element names outside safety bounds.\n\nExamples: \n\nWriting and reading a time series into a file\n\n\n\nPSRI.open(reader::Type{<:AbstractReader}, path::String; kwargs...)\n\nMethod for opening file and reading time series data. Returns updated AbstractReader instance.\n\nArguments:\n\nreader::Type{<:AbstractReader}: AbstractReader instance to be used for opening file.\npath::String: path to file.\n\nKeyword arguments:\n\nis_hourly::Bool: if data to be read is hourly, other than blockly.\nstage_type::PSRI.StageType: the PSRI.StageType of the data, defaults to PSRI.STAGE_MONTH.\nheader::Vector{String}: if file has a header with metadata.\nuse_header::Bool: if data from header should be retrieved.\nfirst_stage::Dates.Date: stage at which start reading.\nverbose_header::Bool: if data from header should be displayed during execution.\n\nExamples: \n\nWriting and reading a time series into a file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.close","page":"Manual","title":"PSRClassesInterface.close","text":"PSRI.close(ior::AbstractReader)\n\nCloses the PSRI.AbstractReader instance.\n\n\n\nPSRI.close(iow::AbstractWriter)\n\nCloses the PSRI.AbstractWriter instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-entire-file","page":"Manual","title":"Write entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.array_to_file","category":"page"},{"location":"manual/#PSRClassesInterface.array_to_file","page":"Manual","title":"PSRClassesInterface.array_to_file","text":"PSRI.array_to_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-registry","page":"Manual","title":"Write registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.write_registry","category":"page"},{"location":"manual/#PSRClassesInterface.write_registry","page":"Manual","title":"PSRClassesInterface.write_registry","text":"PSRI.write_registry(\n    iow::AbstractWriter,\n    data::Vector{T},\n    stage::Integer,\n    scenario::Integer = 1,\n    block::Integer = 1,\n) where T <: Real\n\nWrites a data row into opened file through PSRI.AbstractWriter instance.\n\nArguments:\n\niow: PSRI.AbstractWriter instance to be used for accessing file.\ndata: elements data to be written.\nstage: stage of the data to be written.\nscenario: scenarios of the data to be written.\nblock: block of the data to be written.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-Graf-files","page":"Manual","title":"Read Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close-2","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractReader\nPSRClassesInterface.open\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractReader","page":"Manual","title":"PSRClassesInterface.AbstractReader","text":"PSRI.AbstractReader\n\n\n\n\n\n","category":"type"},{"location":"manual/#Header-information","page":"Manual","title":"Header information","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.is_hourly\nPSRClassesInterface.hour_discretization\nPSRClassesInterface.max_stages\nPSRClassesInterface.max_scenarios\nPSRClassesInterface.max_blocks\nPSRClassesInterface.max_blocks_current\nPSRClassesInterface.max_blocks_stage\nPSRClassesInterface.max_agents\nPSRClassesInterface.stage_type\nPSRClassesInterface.initial_stage\nPSRClassesInterface.initial_year\nPSRClassesInterface.data_unit\nPSRClassesInterface.agent_names","category":"page"},{"location":"manual/#PSRClassesInterface.is_hourly","page":"Manual","title":"PSRClassesInterface.is_hourly","text":"PSRI.is_hourly(ior::AbstractReader)\n\nReturns a Bool indicating whether the data in the file read by PSRI.AbstractReader is hourly.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.hour_discretization","page":"Manual","title":"PSRClassesInterface.hour_discretization","text":"PSRI.hour_discretization(ior::AbstractReader)\n\nReturns an Int indicating the hour discretization.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_stages","page":"Manual","title":"PSRClassesInterface.max_stages","text":"PSRI.max_stages(ior::AbstractReader)\n\nReturns an Int indicating maximum number of stages in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_scenarios","page":"Manual","title":"PSRClassesInterface.max_scenarios","text":"PSRI.max_scenarios(ior::AbstractReader)\n\nReturns an Int indicating maximum number of scenarios in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks","page":"Manual","title":"PSRClassesInterface.max_blocks","text":"PSRI.max_blocks(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_current","page":"Manual","title":"PSRClassesInterface.max_blocks_current","text":"PSRI.max_blocks_current(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the cuurent stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_stage","page":"Manual","title":"PSRClassesInterface.max_blocks_stage","text":"PSRI.max_blocks_stage(ior::AbstractReader, t::Integer)\n\nReturns an Int indicating maximum number of blocks in the stage t in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_agents","page":"Manual","title":"PSRClassesInterface.max_agents","text":"PSRI.max_agents(ior::AbstractReader)\n\nReturns an Int indicating maximum number of agents in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.stage_type","page":"Manual","title":"PSRClassesInterface.stage_type","text":"stage_type\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_stage","page":"Manual","title":"PSRClassesInterface.initial_stage","text":"PSRI.initial_stage(ior::AbstractReader)\n\nReturns an Int indicating the initial stage in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_year","page":"Manual","title":"PSRClassesInterface.initial_year","text":"PSRI.initial_year(ior::AbstractReader)\n\nReturns an Int indicating the initial year in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.data_unit","page":"Manual","title":"PSRClassesInterface.data_unit","text":"PSRI.data_unit(ior::AbstractReader)\n\nReturns a String indicating the unit of the data in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.agent_names","page":"Manual","title":"PSRClassesInterface.agent_names","text":"PSRI.agent_names(ior::AbstractReader)\n\nReturns a Vector{String} with the agent names in the file read by PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-entire-file","page":"Manual","title":"Read entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.file_to_array\nPSRClassesInterface.file_to_array_and_header","category":"page"},{"location":"manual/#PSRClassesInterface.file_to_array","page":"Manual","title":"PSRClassesInterface.file_to_array","text":"PSRI.file_to_array(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.file_to_array_and_header","page":"Manual","title":"PSRClassesInterface.file_to_array_and_header","text":"PSRI.file_to_array_and_header(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array and header\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-registry","page":"Manual","title":"Read registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.current_stage\nPSRClassesInterface.current_scenario\nPSRClassesInterface.current_block\nPSRClassesInterface.goto\nPSRClassesInterface.next_registry","category":"page"},{"location":"manual/#PSRClassesInterface.current_stage","page":"Manual","title":"PSRClassesInterface.current_stage","text":"PSRI.current_stage(ior::AbstractReader)\n\nReturns an Int indicating the current stage in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_scenario","page":"Manual","title":"PSRClassesInterface.current_scenario","text":"PSRI.current_scenario(ior::AbstractReader)\n\nReturns an Int indicating the current scenarios in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_block","page":"Manual","title":"PSRClassesInterface.current_block","text":"PSRI.current_block(ior::AbstractReader)\n\nReturns an Int indicating the current block in the stream of the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.goto","page":"Manual","title":"PSRClassesInterface.goto","text":"PSRI.goto(\n    ior::AbstractReader, \n    t::Integer, \n    s::Integer = 1, \n    b::Integer = 1\n)\n\nGoes to the registry of the stage t, scenario s and block b.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.next_registry","page":"Manual","title":"PSRClassesInterface.next_registry","text":"PSRI.next_registry(ior::AbstractReader)\n\nGoes to the next registry on the PSRI.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#File-conversion","page":"Manual","title":"File conversion","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.convert_file\nPSRClassesInterface.add_reader!","category":"page"},{"location":"manual/#PSRClassesInterface.convert_file","page":"Manual","title":"PSRClassesInterface.convert_file","text":"convert_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.add_reader!","page":"Manual","title":"PSRClassesInterface.add_reader!","text":"add_reader!\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reader-mapper","page":"Manual","title":"Reader mapper","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.ReaderMapper\nPSRClassesInterface.add_reader!\nPSRClassesInterface.goto\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.ReaderMapper","page":"Manual","title":"PSRClassesInterface.ReaderMapper","text":"ReaderMapper{T}\n\n\n\n\n\n","category":"type"},{"location":"manual/#Modification-API","page":"Manual","title":"Modification API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.create_study\nPSRClassesInterface.create_element!\nPSRClassesInterface.set_parm!\nPSRClassesInterface.set_vector!\nPSRClassesInterface.set_series!\nPSRClassesInterface.write_data\nPSRClassesInterface.set_related!\nPSRClassesInterface.set_vector_related!","category":"page"},{"location":"manual/#PSRClassesInterface.create_study","page":"Manual","title":"PSRClassesInterface.create_study","text":"create_study(::AbstractStudyInterface; kwargs...)\n\nReturns the Data object of a new study.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.create_element!","page":"Manual","title":"PSRClassesInterface.create_element!","text":"create_element!(\n    data::Data,\n    collection::String,\n    ps::Pair{String,<:Any};\n    default::Union{Dict{String,Any},Nothing} = nothing\n)\n\nCreates a new instance of the given collection and returns its index.\n\nExample:\n\nindex = PSRI.create_element!(data, \"PSRClass\")\n\nPSRI.set_parm!(data, \"PSRClass\", index, \"PSRAttr\", value)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_parm!","page":"Manual","title":"PSRClassesInterface.set_parm!","text":"set_parm!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    value::T,\n) where {T <: MainTypes}\n\nDefines the value of a scalar parameter.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector!","page":"Manual","title":"PSRClassesInterface.set_vector!","text":"function set_vector!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Int,\n    buffer::Vector{T}\n) where {T<:MainTypes}\n\nUpdates a data vector according to the given buffer. Note: Modifying current vector length is not allowed: use set_series! instead.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_series!","page":"Manual","title":"PSRClassesInterface.set_series!","text":"function set_series!(\n    data::Data,\n    collection::String,\n    index_attr::String,\n    index::Int,\n    buffer::Dict{String,Vector}\n)\n\nUpdates serial (indexed) data. All columns must be the same as before. The series length is allowed to be changed, but all vectors in the new series must have equal length.\n\njulia> series = Dict{String, Vector}(\n         \"GerMin\" => [0.0, 1.0],\n         \"GerMax\" => [888.0, 777.0],\n         \"NGas\" => [nothing, nothing],\n         \"IH\" => [0.0, 0.0],\n         \"CoefE\" => [1.0, 2.0],\n         \"PotInst\" => [888.0, 777.0],\n         \"ICP\" => [0.0, 0.0],\n         \"Data\" => [\"1900-01-01\", \"1900-01-02\"],\n         \"Existing\" => [0, 0],\n         \"sfal\" => [0, 1],\n         \"NAdF\" => [0, 0],\n         \"Unidades\" => [1, 1],\n         \"StartUp\" => [0.0, 2.0]\n       );\n\njulia> PSRI.set_series!(data, \"PSRThermalPlant\", 1, \"Data\", series)\n\njulia> PSRI.get_series(data, \"PSRThermalPlant\", 1, \"Data\")\nDict{String, Vector} with 13 entries:\n  \"GerMin\"   => [0.0, 1.0]\n  \"GerMax\"   => [888.0, 777.0]\n  \"NGas\"     => [nothing, nothing]\n  \"IH\"       => [0.0, 0.0]\n  \"ICP\"      => [0.0, 0.0]\n  \"Data\"     => [\"1900-01-01\", \"1900-01-02\"]\n  \"CoefE\"    => [1.0, 2.0]\n  \"PotInst\"  => [888.0, 777.0]\n  \"Existing\" => [0, 0]\n  \"sfal\"     => [0, 1]\n  \"NAdF\"     => [0, 0]\n  \"Unidades\" => [1, 1]\n  \"StartUp\"  => [0.0, 2.0]\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.write_data","page":"Manual","title":"PSRClassesInterface.write_data","text":"write_data(data::Data, path::String)\n\nWrites data to file in JSON format.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_related!","page":"Manual","title":"PSRClassesInterface.set_related!","text":"set_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Integer;\n    relation_type = RELATION_1_TO_1,\n)\n\nSets the element source_index from collection source to be related to the element target_index from collection target in the scalar relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector_related!","page":"Manual","title":"PSRClassesInterface.set_vector_related!","text":"set_vector_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Vector{<:Integer};\n    relation_type = RELATION_1_TO_N,\n)\n\nSets the element source_index from collection source to be related to the elements in target_index from collection target in the vector relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"#PSRClassesInterface-Documentation","page":"Home","title":"PSRClassesInterface Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository to read and write open-source formats for PSR models.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered so you can simply add it using Julia's Pkg manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PSRClassesInterface","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide","category":"page"}]
}
