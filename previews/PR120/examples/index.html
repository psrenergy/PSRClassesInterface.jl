<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · PSRClassesInterface.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PSRClassesInterface.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Writing-and-reading-a-time-series-into-a-file"><span>Writing and reading a time series into a file</span></a></li><li><a class="tocitem" href="#Reading-configuration-parameters"><span>Reading configuration parameters</span></a></li><li><a class="tocitem" href="#Reading-basic-thermal-generator-parameters"><span>Reading basic thermal generator parameters</span></a></li><li><a class="tocitem" href="#Reading-basic-battery-parameters"><span>Reading basic battery parameters</span></a></li><li><a class="tocitem" href="#Determining-subsystem-from-a-certain-hydro-plant"><span>Determining subsystem from a certain hydro plant</span></a></li><li><a class="tocitem" href="#Determining-buses-from-a-certain-thermal-plant"><span>Determining buses from a certain thermal plant</span></a></li><li><a class="tocitem" href="#Determining-elasticity-and-value-of-demands"><span>Determining elasticity and value of demands</span></a></li><li><a class="tocitem" href="#Determining-which-buses-are-connected-by-each-circuit"><span>Determining which buses are connected by each circuit</span></a></li><li><a class="tocitem" href="#Calculating-the-energy-prices-of-each-thermal-plant"><span>Calculating the energy prices of each thermal plant</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/psrenergy/PSRClassesInterface.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Writing-and-reading-a-time-series-into-a-file"><a class="docs-heading-anchor" href="#Writing-and-reading-a-time-series-into-a-file">Writing and reading a time series into a file</a><a id="Writing-and-reading-a-time-series-into-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-and-reading-a-time-series-into-a-file" title="Permalink"></a></h2><p>In this example we will demonstrate how to save a time series into a csv or binary file.  The first step is to obtain the data that you wish to save</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

#Creates dummy data
n_blocks = 2
n_scenarios = 3
n_stages = 4
n_agents = 5

time_series_data = rand(Float64, n_agents, n_blocks, n_scenarios, n_stages)</code></pre><p>There are two ways of saving the data to a file, save the data in the file directly or iteratively. To save the data directly use the function <a href="../manual/#PSRClassesInterface.array_to_file"><code>PSRI.array_to_file</code></a> by calling:</p><pre><code class="language-julia hljs">FILE_PATH = joinpath(&quot;.&quot;, &quot;example&quot;)

PSRI.array_to_file(
    PSRI.OpenBinary.Writer,
    FILE_PATH,
    time_series_data,
    agents = [&quot;Agent 1&quot;, &quot;Agent 2&quot;, &quot;Agent 3&quot;, &quot;Agent 4&quot;, &quot;Agent 5&quot;],
    unit = &quot;MW&quot;;
    initial_stage = 3,
    initial_year = 2006,
)</code></pre><p>To save the data iteractively use the function <a href="../manual/#PSRClassesInterface.open"><code>PSRI.open</code></a> to create an <a href="../manual/#PSRClassesInterface.AbstractWriter"><code>PSRI.AbstractWriter</code></a>. Save the data of each registry to the file using the function <a href="../manual/#PSRClassesInterface.write_registry"><code>PSRI.write_registry</code></a> and then close the data stream calling the function <a href="../manual/#PSRClassesInterface.close"><code>PSRI.close</code></a>.</p><pre><code class="language-julia hljs">iow = PSRI.open(
    PSRI.OpenBinary.Writer,
    FILE_PATH,
    blocks = n_blocks,
    scenarios = n_scenarios,
    stages = n_stages,
    agents = [&quot;Agent 1&quot;, &quot;Agent 2&quot;, &quot;Agent 3&quot;, &quot;Agent 4&quot;, &quot;Agent 5&quot;],
    unit = &quot;MW&quot;,
    initial_stage = 1,
    initial_year = 2006,
)

for stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks
    PSRI.write_registry(
        iow,
        time_series_data[:, block, scenario, stage],
        stage,
        scenario,
        block
    )
end

PSRI.close(iow)</code></pre><p>A similar logic can be used to read the data from a file. You can read it directly or iteratively. To read the data directly use the function <a href="../manual/#PSRClassesInterface.file_to_array"><code>PSRI.file_to_array</code></a> or <a href="../manual/#PSRClassesInterface.file_to_array_and_header"><code>PSRI.file_to_array_and_header</code></a></p><pre><code class="language-julia hljs">data_from_file = PSRI.file_to_array(
        PSRI.OpenBinary.Reader,
        FILE_PATH;
        use_header=false
    )

@assert all(isapprox.(data_from_file, time_series_data, atol=1E-7))

data_from_file_and_header, header = PSRI.file_to_array_and_header(
        PSRI.OpenBinary.Reader,
        FILE_PATH;
        use_header=false
    )
@assert all(isapprox.(data_from_file_and_header, time_series_data, atol=1E-7))</code></pre><p>To read the data iteractively use the function <a href="../manual/#PSRClassesInterface.open"><code>PSRI.open</code></a> to create an <a href="../manual/#PSRClassesInterface.AbstractReader"><code>PSRI.AbstractReader</code></a> and read each registry iteratively. At the end you should close the <a href="../manual/#PSRClassesInterface.AbstractReader"><code>PSRI.AbstractReader</code></a> by calling <a href="../manual/#PSRClassesInterface.close"><code>PSRI.close</code></a></p><pre><code class="language-julia hljs">ior = PSRI.open(
    PSRI.OpenBinary.Reader,
    FILE_PATH;
    use_header = false
)

data_from_file = zeros(n_agents, n_blocks, n_scenarios, n_stages)

for stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks
    PSRI.next_registry(ior)
    data_from_file[:, block, scenario, stage] = ior.data
end

PSRI.close(ior)

rm(FILE_PATH; force = true)</code></pre><p>To choose the agents order use <code>use_header</code> and <code>header</code></p><pre><code class="language-julia hljs">data_from_file = PSRI.file_to_array(
        PSRI.OpenBinary.Reader,
        FILE_PATH;
        use_header=true,
        header=[&quot;Agent 5&quot;, &quot;Agent 2&quot;, &quot;Agent 3&quot;, &quot;Agent 4&quot;, &quot;Agent 1&quot;]
    )
@assert all(isapprox.(data_from_file[1, :, :, :], time_series_data[end, :, :, :], atol=1E-7))
@assert all(isapprox.(data_from_file[end, :, :, :], time_series_data[1, :, :, :], atol=1E-7))</code></pre><h2 id="Reading-configuration-parameters"><a class="docs-heading-anchor" href="#Reading-configuration-parameters">Reading configuration parameters</a><a id="Reading-configuration-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-configuration-parameters" title="Permalink"></a></h2><p>Most cases have configuration parameters such as the maximum number of iterations, the discount rate, the deficit cost etc. The function <a href="../manual/#PSRClassesInterface.configuration_parameter"><code>PSRI.configuration_parameter</code></a> reads all the parameters from the cases.</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_CONFIGS = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso0&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_CONFIGS
)

PSRI.configuration_parameter(data, &quot;TaxaDesconto&quot;, 0.0)
PSRI.configuration_parameter(data, &quot;MaximoIteracoes&quot;, 0)
PSRI.configuration_parameter(data, &quot;MaximoIteracoes&quot;, 0)
PSRI.configuration_parameter(data, &quot;MinOutflowPenalty&quot;, 0.0)
PSRI.configuration_parameter(data, &quot;DeficitCost&quot;, [0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 500.0</code></pre><h2 id="Reading-basic-thermal-generator-parameters"><a class="docs-heading-anchor" href="#Reading-basic-thermal-generator-parameters">Reading basic thermal generator parameters</a><a id="Reading-basic-thermal-generator-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-basic-thermal-generator-parameters" title="Permalink"></a></h2><p>In this example we will map parameters of thermal generators at each stage of the study to a struct. Suppose in this case that our thermal generators has the following attributes:</p><pre><code class="language-julia hljs">Base.@kwdef mutable struct ThermalGenerators
    names::Vector{String} = String[]
    codes::Vector{Int32} = Int32[]
    generation_capacities::Vector{Float64} = Float64[]
    therm2sys::Vector{Int32} = Int32[]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.ThermalGenerators</code></pre><p>The first thing we must do is to initialize the reading procedure with the following commands:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_THERMALS = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso0&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_THERMALS
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>We can initialize the struct with the parameters of the first stage using the function <a href="../manual/#PSRClassesInterface.mapped_vector"><code>PSRI.mapped_vector</code></a></p><pre><code class="language-julia hljs">therm_gen = ThermalGenerators()
therm_gen.names = PSRI.get_name(data, &quot;PSRThermalPlant&quot;)
therm_gen.codes = PSRI.get_code(data, &quot;PSRThermalPlant&quot;)
therm_gen.generation_capacities = PSRI.mapped_vector(data, &quot;PSRThermalPlant&quot;, &quot;PotInst&quot;, Float64)
therm_gen.therm2sys = PSRI.get_map(data, &quot;PSRThermalPlant&quot;, &quot;PSRSystem&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int32}:
 1
 1
 1</code></pre><p>And afterwards we can update the parameters for each stage as follows.</p><pre><code class="language-julia hljs">for stage in 1:PSRI.total_stages(data)
    PSRI.go_to_stage(data, stage)
    PSRI.update_vectors!(data)
    println(&quot;Thermal generator 2 generation capacity at stage $stage $(therm_gen.generation_capacities[2])&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Thermal generator 2 generation capacity at stage 1 5.0
Thermal generator 2 generation capacity at stage 2 5.0</code></pre><h2 id="Reading-basic-battery-parameters"><a class="docs-heading-anchor" href="#Reading-basic-battery-parameters">Reading basic battery parameters</a><a id="Reading-basic-battery-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-basic-battery-parameters" title="Permalink"></a></h2><p>This example is very similar to &quot;Reading basic thermal generator parameters&quot;, but it is necessary to be cautious about the difference between elements. For instance, batteries have different parameters than thermal generators, therefore, our data structure must be defined accordingly:</p><pre><code class="language-julia hljs">Base.@kwdef mutable struct Batteries
    names::Vector{String} = String[]
    codes::Vector{Int32} = Int32[]
    charge_eff::Vector{Float64} = Float64[]
    bat2sys::Vector{Int32} = Int32[]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Batteries</code></pre><p>Stardard proceadure of reading data from file:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_BATTERIES = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso1&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_BATTERIES
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>And now the struct may be instantiated by setting its appropriate parameters:</p><pre><code class="language-julia hljs">batteries = Batteries()
batteries.names = PSRI.get_name(data, &quot;PSRBattery&quot;)
batteries.codes = PSRI.get_code(data, &quot;PSRBattery&quot;)
batteries.charge_eff = PSRI.mapped_vector(data, &quot;PSRBattery&quot;, &quot;ChargeEffic&quot;, Float64)
batteries.bat2sys = PSRI.get_map(data, &quot;PSRBattery&quot;, &quot;PSRSystem&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int32}:
 1
 1
 1</code></pre><h2 id="Determining-subsystem-from-a-certain-hydro-plant"><a class="docs-heading-anchor" href="#Determining-subsystem-from-a-certain-hydro-plant">Determining subsystem from a certain hydro plant</a><a id="Determining-subsystem-from-a-certain-hydro-plant-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-subsystem-from-a-certain-hydro-plant" title="Permalink"></a></h2><p>In this example we will demonstrate how to make a simple use of a relationship map. That will be achieved by determining a subsystem from a certain hydro plant through its parameters. The program will initiate by the standard reading procedure:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_GAUGING = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso2&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_GAUGING
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>Next, the maps between hydroplants and systems is retrieved by the <code>get_map</code> method:</p><pre><code class="language-julia hljs">hyd2sys = PSRI.get_map(data, &quot;PSRHydroPlant&quot;,&quot;PSRSystem&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int32}:
 1
 1</code></pre><h2 id="Determining-buses-from-a-certain-thermal-plant"><a class="docs-heading-anchor" href="#Determining-buses-from-a-certain-thermal-plant">Determining buses from a certain thermal plant</a><a id="Determining-buses-from-a-certain-thermal-plant-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-buses-from-a-certain-thermal-plant" title="Permalink"></a></h2><p>This case consists of a more advanced use of a relationship map. We&#39;ll determine which buses are linked to a given target thermal plant, while there is no direct relationship between both. Firstly, the study data is read:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_BUS = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso1&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_BUS
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>Whereas there is no direct link between buses and thermal plants, both are indirectly related through generators. Therefore, we must identify those relationships by calling <code>get_map</code> for each:</p><pre><code class="language-julia hljs">gen2thermal = PSRI.get_map(data, &quot;PSRGenerator&quot;,&quot;PSRThermalPlant&quot;)
gen2bus = PSRI.get_map(data, &quot;PSRGenerator&quot;, &quot;PSRBus&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Int32}:
  20
  33
  39
  51
  71
  86
  93
 109
 117</code></pre><p>Next, we can find which generators are linked to our target thermal plant by the indexes of <code>gen2the</code>:</p><pre><code class="language-julia hljs">target_thermal = 1
target_generator = findall(isequal(target_thermal), gen2thermal)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int64}:
 9</code></pre><p><code>target_generator</code> now holds the indexes of generators that are linked to the buses we are trying to identify. With those at hand, the indexes of the buses are easily identifiable by:</p><pre><code class="language-julia hljs">targetBus = gen2bus[target_generator]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int32}:
 117</code></pre><h2 id="Determining-elasticity-and-value-of-demands"><a class="docs-heading-anchor" href="#Determining-elasticity-and-value-of-demands">Determining elasticity and value of demands</a><a id="Determining-elasticity-and-value-of-demands-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-elasticity-and-value-of-demands" title="Permalink"></a></h2><p>In this example we will read demand segments, obtain the value of demands, discover wheter each demand is elastic or inelastic, and then obtain the sums of demands by elasticity. The first step is to read the study data:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_DEM = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso1&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_DEM
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>Whereas the demand varies according to the stage, we must specify the stage by calling <code>go_to_stage</code>:</p><pre><code class="language-julia hljs">target_stage = 1
PSRI.go_to_stage(data,target_stage)</code></pre><p>Now, we can read the demand segments and the map between demands and demand segments, and then obtain the value of each demand:</p><pre><code class="language-julia hljs">dem_seg = PSRI.mapped_vector(data, &quot;PSRDemandSegment&quot;, &quot;Demanda&quot;, Float64, &quot;block&quot;)

seg2dem = PSRI.get_map(data, &quot;PSRDemandSegment&quot;, &quot;PSRDemand&quot;, relation_type = PSRI.RELATION_1_TO_1)

dem_size = PSRI.max_elements(data, &quot;PSRDemand&quot;)

demand_values = zeros(dem_size)

for demand = 1:dem_size
    demand_values[demand] = sum(dem_seg[i] for i = 1:length(dem_seg) if seg2dem[i] == demand)
end

demand_values</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.38948</code></pre><p>We can discover the elasticity of each demand by calling <code>get_parms</code> with the parameter <code>Elastico</code>:</p><pre><code class="language-julia hljs">demands_elasticity = PSRI.get_parms(data, &quot;PSRDemand&quot;, &quot;Elastico&quot;, Int32)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int32}:
 0</code></pre><p>If <code>demands_elasticity[i] == 0</code> it means that the demand at index <code>i</code> is inelastic, and elastic if <code>demands_elasticity[i] == 1</code>. We can now obtain the total demands of each elasticity:</p><pre><code class="language- hljs">total_elastic_demand = 0.0
total_inelastic_demand = 0.0

for i = 1:dem_size
    if demands_elasticity[i] == 0
        total_inelastic_demand += demand_values[i]
    else
        total_elastic_demand += demand_values[i]
    end
end</code></pre><h3 id="Determining-demands-values-of-each-bus"><a class="docs-heading-anchor" href="#Determining-demands-values-of-each-bus">Determining demands values of each bus</a><a id="Determining-demands-values-of-each-bus-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-demands-values-of-each-bus" title="Permalink"></a></h3><p>Now we have the values of the demands, we can obtain the values of demand for each bus.  Each demand has a set of loads, which define how much of this demand corresponds to each bus.  We can begin by reading the loads and its relations with demands and buses:</p><pre><code class="language-julia hljs">loads = PSRI.mapped_vector(data, &quot;PSRLoad&quot;, &quot;P&quot;, Float64, &quot;block&quot;)
lod2dem = PSRI.get_map(data, &quot;PSRLoad&quot;, &quot;PSRDemand&quot;, relation_type = PSRI.RELATION_1_TO_1)
lod2bus = PSRI.get_map(data, &quot;PSRLoad&quot;, &quot;PSRBus&quot;, relation_type = PSRI.RELATION_1_TO_1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Int32}:
   1
   2
   4
   5
   6
   7
   9
  10
  11
  12
   ⋮
 103
 104
 106
 107
 109
 111
 112
 113
 114</code></pre><p>The values of the loads are weights in a kind of a weighted arithmetic mean of the buses for each demand. But the loads of each demand don&#39;t add up to 1, so they need to be normalized to represent fractions of the total:</p><pre><code class="language-julia hljs">total_lod_bydem = zeros(dem_size)
lod_size = PSRI.max_elements(data, &quot;PSRLoad&quot;)

for i in 1:lod_size
    total_lod_bydem[lod2dem[i]] += loads[i]
end

for i in 1:lod_size
    if total_lod_bydem[lod2dem[i]] &gt; 0.0
        loads[i] = loads[i]/total_lod_bydem[lod2dem[i]]
    else
        loads[i] = 0.0
    end
end

loads</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Float64}:
 0.011461318051575926
 0.005730659025787963
 0.011461318051575926
 0.005730659025787963
 0.011461318051575926
 0.005730659025787963
 0.011461318051575926
 0.005730659025787963
 0.011461318051575926
 0.005730659025787963
 ⋮
 0.011461318051575926
 0.011461318051575926
 0.011461318051575926
 0.011461318051575926
 0.011461318051575926
 0.005730659025787963
 0.005730659025787963
 0.011461318051575926
 0.005730659025787963</code></pre><p>Now we know the fraction of each demand that corresponds to each bus, and can easily define the total demand by bus:</p><pre><code class="language-julia hljs">bus_size = PSRI.max_elements(data, &quot;PSRBus&quot;)

dem_bybus = zeros(bus_size)

for lod = 1:lod_size
    fraction = loads[lod]
    dem = lod2dem[lod]
    bus = lod2bus[lod]
    dem_bybus[bus] += demand_values[dem]*fraction
end

dem_bybus</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">129-element Vector{Float64}:
 0.004463954154727791
 0.0022319770773638957
 0.0
 0.004463954154727791
 0.0022319770773638957
 0.004463954154727791
 0.0022319770773638957
 0.0
 0.004463954154727791
 0.0022319770773638957
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><h2 id="Determining-which-buses-are-connected-by-each-circuit"><a class="docs-heading-anchor" href="#Determining-which-buses-are-connected-by-each-circuit">Determining which buses are connected by each circuit</a><a id="Determining-which-buses-are-connected-by-each-circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-which-buses-are-connected-by-each-circuit" title="Permalink"></a></h2><p>Each circuit connects two buses, it starts from a bus and goes to another. In this example we&#39;ll discover these buses for each circuit and then we&#39;ll build an incidence matrix of buses by circuits. The first step is to read the data:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_CIR_BUS = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso1&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_CIR_BUS
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>Next, we get from which bus each circuit starts and which bus it goes to with <code>get_map</code>:</p><pre><code class="language-julia hljs">cir2bus_to = PSRI.get_map(data, &quot;PSRSerie&quot;, &quot;PSRBus&quot;; relation_type = PSRI.RELATION_TO)
cir2bus_from = PSRI.get_map(data, &quot;PSRSerie&quot;, &quot;PSRBus&quot;; relation_type = PSRI.RELATION_FROM)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">134-element Vector{Int32}:
   1
   1
   1
   3
   3
   5
   7
   8
   8
   8
   ⋮
 123
 127
  54
 118
 125
 117
  61
  61
 117</code></pre><p>Now we can build the incidence matrix. Each row corresponds to a circuit and each column corresponds to a bus. The element at the index (i,j) is -1 if the circuit i starts from the bus j, 1 if it goes to this bus, and 0 if they both have no relation:</p><pre><code class="language-julia hljs">bus_size = PSRI.max_elements(data, &quot;PSRBus&quot;)
cir_size = PSRI.max_elements(data, &quot;PSRSerie&quot;)
incidence_matrix = zeros(Float64, cir_size, bus_size)
for cir = 1:cir_size
    incidence_matrix[cir, cir2bus_from[cir]] = -1.0
    incidence_matrix[cir, cir2bus_to[cir]] = 1.0
end
incidence_matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">134×129 Matrix{Float64}:
 -1.0  1.0   0.0  0.0   0.0  0.0   0.0  …  0.0   0.0  0.0   0.0  0.0  0.0
 -1.0  0.0   1.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
 -1.0  0.0   0.0  0.0   0.0  0.0   1.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0  -1.0  1.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0  -1.0  0.0   1.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0  -1.0  1.0   0.0  …  0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0  -1.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  ⋮                          ⋮          ⋱             ⋮               
  0.0  0.0   0.0  0.0   0.0  0.0   0.0  …  1.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0  -1.0  1.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   1.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0  -1.0  1.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0  …  0.0   0.0  0.0   0.0  0.0  0.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  1.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  1.0
  0.0  0.0   0.0  0.0   0.0  0.0   0.0     0.0   0.0  0.0   0.0  0.0  0.0</code></pre><h2 id="Calculating-the-energy-prices-of-each-thermal-plant"><a class="docs-heading-anchor" href="#Calculating-the-energy-prices-of-each-thermal-plant">Calculating the energy prices of each thermal plant</a><a id="Calculating-the-energy-prices-of-each-thermal-plant-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-energy-prices-of-each-thermal-plant" title="Permalink"></a></h2><p>The energy prices in a thermal plant deppends on the  the price of the fuel used, the specific consumption of this fuel and Operation and Maintenance cost. Again, we begin by reading the data:</p><pre><code class="language-julia hljs">import PSRClassesInterface
const PSRI = PSRClassesInterface

PATH_CASE_EXAMPLE_THER_PRICES = joinpath(pathof(PSRI) |&gt; dirname |&gt; dirname, &quot;test&quot;, &quot;data&quot;, &quot;caso1&quot;)

data = PSRI.initialize_study(
    PSRI.OpenInterface(),
    data_path = PATH_CASE_EXAMPLE_THER_PRICES
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PSRClasses Study with 35 collections:
    PSRArea
    PSRBattery
    PSRBus
    PSRCircuitSumData
    PSRCspPlant
    PSRCurrency
    PSRDemand
    PSRDemandSegment
    PSRFuel
    PSRFuelConsumption
    PSRFuelContract
    PSRFuelReservoir
    PSRGasEmission
    PSRGasNode
    PSRGasPipeline
    PSRGaugingStation
    PSRGenerationConstraintData
    PSRGndGaugingStation
    PSRGndPlant
    PSRHydroPlant
    PSRHydrologicalPlantConnection
    PSRInterconnection
    PSRInterconnectionSumData
    PSRLinkDC
    PSRLoad
    PSRMaintenanceData
    PSRPowerInjection
    PSRReserveGenerationConstraintData
    PSRReservoirSet
    PSRSerie
    PSRStudy
    PSRSystem
    PSRThermalCombinedCycle
    PSRThermalPlant
    PSRTransformer
</code></pre><p>We discover the necessary infos of the thermal plants indirectly through <code>PSRFuelConsumption</code>:</p><pre><code class="language-julia hljs">fuelcons2ther = PSRI.get_map(data,&quot;PSRFuelConsumption&quot;, &quot;PSRThermalPlant&quot;; relation_type = PSRI.RELATION_1_TO_1)

ther_size = PSRI.max_elements(data, &quot;PSRThermalPlant&quot;)
fuelcons_size = PSRI.max_elements(data, &quot;PSRFuelConsumption&quot;)
ther2fuelcons = [[fc for fc = 1:fuelcons_size if fuelcons2ther[fc] == t] for t = 1:ther_size]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]</code></pre><p>Next, we get the O&amp;M cost, the specific consumption and the relation with fuels of our fuels consumptions. Then we get the cost of each fuel. After calling <code>mapped_vector</code> we must call <code>update_vectors!</code>.</p><pre><code class="language-julia hljs">om_cost = PSRI.mapped_vector(data, &quot;PSRFuelConsumption&quot;, &quot;O&amp;MCost&quot;, Float64)
spec_consum = PSRI.mapped_vector(data, &quot;PSRFuelConsumption&quot;, &quot;CEsp&quot;, Float64, &quot;segment&quot;, &quot;block&quot;)
fuelcons2fuel = PSRI.get_map(data, &quot;PSRFuelConsumption&quot;, &quot;PSRFuel&quot;; relation_type = PSRI.RELATION_1_TO_1)
fuel_cost = PSRI.mapped_vector(data, &quot;PSRFuel&quot;, &quot;Custo&quot;, Float64)

PSRI.update_vectors!(data)</code></pre><p>Now we can calculate the price of the energy unity of each fuel consumption for each thermal plant:</p><pre><code class="language-julia hljs">ther_prices = [zeros(0) for _ = 1:ther_size]
for ther = 1:ther_size
    n_fuelcons = length(ther2fuelcons[ther])
    prices = zeros(n_fuelcons)
    for i = 1:n_fuelcons
        fuelcons = ther2fuelcons[ther][i]
        fuel = fuelcons2fuel[fuelcons]
        prices[i] = om_cost[fuelcons] + spec_consum[fuelcons]*fuel_cost[fuel]
    end
    ther_prices[ther] = prices
end
ther_prices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{Float64}}:
 [100.0]
 [20.0]
 [40.0]
 [60.0]
 [80.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Manual</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 30 November 2022 21:28">Wednesday 30 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
