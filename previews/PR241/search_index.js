var documenterSearchIndex = {"docs":
[{"location":"examples/modification/#Modifying-a-Study","page":"Modifying a Study","title":"Modifying a Study","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"In this example we will be showing how to modify your study in runtime, adding/deleting elements, setting relations, ...","category":"page"},{"location":"examples/modification/#Creating-a-Study","page":"Modifying a Study","title":"Creating a Study","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"You can modify an existing study or a new one with the following functions:","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRClassesInterface.create_study &rarr; to create a new study;\nPSRClassesInterface.load_study &rarr; to load an old study.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"In this example, we will be working with a new empty study.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\ntemp_path = joinpath(tempdir(), \"PSRI\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(); data_path = temp_path)","category":"page"},{"location":"examples/modification/#Adding-new-elements","page":"Modifying a Study","title":"Adding new elements","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"You can only add elements from collections that are available for your study. Here we will be using our default study configuration, but in another example you can learn how to work with a custom study. You can check which collections are available with PSRI.get_collections(data).","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Every study already comes with a PSRStudy element. So now we can add some elements with the function PSRClassesInterface.create_element!, that returns the element's index in the collection.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"bus_1_index   = PSRI.create_element!(data, \"PSRBus\")\nserie_1_index = PSRI.create_element!(data, \"PSRSerie\")","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"When not specified, the attributes for the element are filled with their default values. But you can also set them manually. If you need, it is possible to see the attributes for a collection with PSRI.get_attributes(data, COLLECTION).","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"bus_2_index = PSRI.create_element!(\n    data, \"PSRBus\", \n    \"name\" => \"bus_name\", \n    \"Kv\" => 1.5, \n    \"code\"=> Int32(98), \n    \"icca\" => Int32(5), \n    \"AVId\" => \"bus_id\"\n    )\n\n# You don't need to set all attributes\n\nbus_3_index = PSRI.create_element!(\n    data, \"PSRBus\", \n    \"code\"=> Int32(10), \n    )","category":"page"},{"location":"examples/modification/#Setting-relations","page":"Modifying a Study","title":"Setting relations","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Some collections in a Study can have relations between some of their elements. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"A Relation has a source and a target element. We can check the available relations for an element when it is a source with PSRI.get_relations(COLLECTION). Just as for custom collections, you can learn how to customize relations in another tutorial.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.set_related!(\n    data, \n    \"PSRSerie\", \n    \"PSRBus\", \n    serie_1_index, \n    bus_1_index , \n    relation_type = PSRI.PMD.RELATION_FROM\n    )\n\nPSRI.set_related!(\n    data, \n    \"PSRSerie\", \n    \"PSRBus\", \n    serie_1_index, \n    bus_2_index , \n    relation_type = PSRI.PMD.RELATION_TO\n    )","category":"page"},{"location":"examples/modification/#Deleting-elements","page":"Modifying a Study","title":"Deleting elements","text":"","category":"section"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"We can delete an element using PSRClassesInterface.delete_element!. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRBus\", bus_3_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"However, if you try to delete an element that has a relation with any other, you will receive an error message. ","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"<span style=\"color:red\">ERROR:</span> Element PSRSerie cannot be deleted because it has relations with other elements","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"So first, you have to check the relations that the element has and delete them.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"To see the relations set to an element, use PSRClassesInterface.relations_summary, which returns a list with the target element, with its index, pointing to the source element, also with its index.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRBus\", bus_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRBus\", bus_2_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.relations_summary(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"Now we know that we have to delete two relations to be able to delete the PSRSerie element. For that, we use PSRClassesInterface.delete_relation!.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_relation!(data, \"PSRSerie\", \"PSRBus\", serie_1_index, bus_1_index)\nPSRI.delete_relation!(data, \"PSRSerie\", \"PSRBus\", serie_1_index, bus_2_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"After that, we can easily delete our PSRSerie element.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.delete_element!(data, \"PSRSerie\", serie_1_index)","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"After that we can save our study to a JSON file, which can later be used to load the study again.","category":"page"},{"location":"examples/modification/","page":"Modifying a Study","title":"Modifying a Study","text":"PSRI.write_data(data)","category":"page"},{"location":"examples/reading_parameters/#Reading-parameters","page":"Reading parameters","title":"Reading parameters","text":"","category":"section"},{"location":"examples/reading_parameters/#Reading-configuration-parameters","page":"Reading parameters","title":"Reading configuration parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Most cases have configuration parameters such as the maximum number of iterations, the discount rate, the deficit cost etc. The function PSRClassesInterface.configuration_parameter reads all the parameters from the cases.","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_CONFIGS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case0\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CONFIGS\n)\n\nPSRI.configuration_parameter(data, \"TaxaDesconto\", 0.0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/#Reading-basic-thermal-generator-parameters","page":"Reading parameters","title":"Reading basic thermal generator parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"In this example we will map parameters of thermal generators at each stage of the study to a struct. Suppose in this case that our thermal generators has the following attributes:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Base.@kwdef mutable struct ThermalGenerators\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    generation_capacities::Vector{Float64} = Float64[]\n    therm2sys::Vector{Int32} = Int32[]\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"The first thing we must do is to initialize the reading procedure with the following commands:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THERMALS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case0\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THERMALS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"We can initialize the struct with the parameters of the first stage using the function PSRClassesInterface.mapped_vector","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"therm_gen = ThermalGenerators()\ntherm_gen.names = PSRI.get_name(data, \"PSRThermalPlant\")\ntherm_gen.codes = PSRI.get_code(data, \"PSRThermalPlant\")\ntherm_gen.generation_capacities = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\ntherm_gen.therm2sys = PSRI.get_map(data, \"PSRThermalPlant\", \"PSRSystem\")\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"And afterwards we can update the parameters for each stage as follows.","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"for stage in 1:PSRI.total_stages(data)\n    PSRI.go_to_stage(data, stage)\n    PSRI.update_vectors!(data)\n    println(\"Thermal generator 2 generation capacity at stage $stage $(therm_gen.generation_capacities[2])\")\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/#Reading-basic-battery-parameters","page":"Reading parameters","title":"Reading basic battery parameters","text":"","category":"section"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"This example is very similar to \"Reading basic thermal generator parameters\", but it is necessary to be cautious about the difference between elements. For instance, batteries have different parameters than thermal generators, therefore, our data structure must be defined accordingly:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Base.@kwdef mutable struct Batteries\n    names::Vector{String} = String[]\n    codes::Vector{Int32} = Int32[]\n    charge_eff::Vector{Float64} = Float64[]\n    bat2sys::Vector{Int32} = Int32[]\nend\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"Stardard proceadure of reading data from file:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BATTERIES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BATTERIES\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"And now the struct may be instantiated by setting its appropriate parameters:","category":"page"},{"location":"examples/reading_parameters/","page":"Reading parameters","title":"Reading parameters","text":"batteries = Batteries()\nbatteries.names = PSRI.get_name(data, \"PSRBattery\")\nbatteries.codes = PSRI.get_code(data, \"PSRBattery\")\nbatteries.charge_eff = PSRI.mapped_vector(data, \"PSRBattery\", \"ChargeEffic\", Float64)\nbatteries.bat2sys = PSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\n; nothing # hide","category":"page"},{"location":"openstudy_files/model_template/#Model-Template","page":"Model Template","title":"Model Template","text":"","category":"section"},{"location":"openstudy_files/model_template/","page":"Model Template","title":"Model Template","text":"The models defined in a PMD file are mapped to collections in an OpenStudy instance with a Model Template file.","category":"page"},{"location":"openstudy_files/model_template/","page":"Model Template","title":"Model Template","text":"A Model Template is a JSON file with the following syntax.","category":"page"},{"location":"openstudy_files/model_template/","page":"Model Template","title":"Model Template","text":"[\n    {\n        \"classname\": \"CustomCollection\",\n        \"models\": [\n            \"Custom_Model_v1\"\n        ]\n    },\n    {\n        \"classname\": \"SecondCollection\",\n        \"models\": [\n            \"Another_Custom_Model_v1\"\n        ]\n    }\n]","category":"page"},{"location":"openstudy_files/model_template/","page":"Model Template","title":"Model Template","text":"Inside classname you define the name of the collection that represents a model stated in models. This model is defined in a PMD file.","category":"page"},{"location":"openstudy_files/model_template/","page":"Model Template","title":"Model Template","text":"To learn more about how to use custom PMD files with Model Templates, see the Customizing a Study example.","category":"page"},{"location":"examples/reading_relations/#Reading-Relations","page":"Reading Relations","title":"Reading Relations","text":"","category":"section"},{"location":"examples/reading_relations/#Introduction-to-the-[PSRClassesInterface.get_map](@ref)-method","page":"Reading Relations","title":"Introduction to the PSRClassesInterface.get_map method","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"There are two dispatches for  the PSRClassesInterface.get_map function.  The first requires the attribute name that represents the relation, while the second needs the PSRClassesInterface.PMD.RelationType between the elements.","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Here is how this function works:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Let's say that in our study we have 3 PSRSerie and 2 PSRBus elements.  There is a relation between elements of these two collections represented by an attribute 'no2', where PSRSerie is the source and PSRBus is the target.","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"If we execute the following code:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPSRI.create_element!(data, \"PSRSerie\")\nPSRI.create_element!(data, \"PSRSerie\")\nPSRI.create_element!(data, \"PSRSerie\")\nPSRI.create_element!(data, \"PSRBus\")\nPSRI.create_element!(data, \"PSRBus\")\n\nPSRI.set_related!(data, \"PSRSerie\", \"PSRBus\", 1, 2, relation_type = PSRI.PMD.RELATION_TO)\nPSRI.set_related!(data, \"PSRSerie\", \"PSRBus\", 3, 1, relation_type = PSRI.PMD.RELATION_TO)\n\nPSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no2\")","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"We could, as an example, get the following vector:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"[ 2 , 0 , 1 ]","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"This means that:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"the source element of index 1 in the collection PSRSerie is related to the target element of index 2 in the collection PSRBus. \nthe source element of index 2 in the collection PSRSerie is not related to any element from collection PSRBus\nthe source element of index 3 in the collection PSRSerie is related to the target element of index 1 in the collection PSRBus. ","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Note: There is also a PSRClassesInterface.get_vector_map method that works just as PSRClassesInterface.get_map. ","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Now we can move to a more practical example.","category":"page"},{"location":"examples/reading_relations/#Determining-subsystem-from-a-certain-hydro-plant","page":"Reading Relations","title":"Determining subsystem from a certain hydro plant","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"In this example we will demonstrate how to make a simple use of a relationship map. That will be achieved by determining a subsystem from a certain hydro plant through its parameters. The program will initiate by the standard reading procedure:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"\nPATH_CASE_EXAMPLE_GAUGING = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case2\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_GAUGING\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, the maps between hydroplants and systems is retrieved by the get_map method:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"hyd2sys = PSRI.get_map(data, \"PSRHydroPlant\",\"PSRSystem\", \"system\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/#Determining-buses-from-a-certain-thermal-plant","page":"Reading Relations","title":"Determining buses from a certain thermal plant","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"This case consists of a more advanced use of a relationship map. We'll determine which buses are linked to a given target thermal plant, while there is no direct relationship between both. Firstly, the study data is read:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_BUS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Whereas there is no direct link between buses and thermal plants, both are indirectly related through generators. Therefore, we must identify those relationships by calling get_map for each:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"gen2thermal = PSRI.get_map(data, \"PSRGenerator\",\"PSRThermalPlant\", \"plant\")\ngen2bus = PSRI.get_map(data, \"PSRGenerator\", \"PSRBus\", \"bus\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, we can find which generators are linked to our target thermal plant by the indexes of gen2the:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"target_thermal = 1\ntarget_generator = findall(isequal(target_thermal), gen2thermal)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"target_generator now holds the indexes of generators that are linked to the buses we are trying to identify. With those at hand, the indexes of the buses are easily identifiable by:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"targetBus = gen2bus[target_generator]\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/#Determining-which-buses-are-connected-by-each-circuit","page":"Reading Relations","title":"Determining which buses are connected by each circuit","text":"","category":"section"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Each circuit connects two buses, it starts from a bus and goes to another. In this example we'll discover these buses for each circuit and then we'll build an incidence matrix of buses by circuits. The first step is to read the data:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"\nPATH_CASE_EXAMPLE_CIR_BUS = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_CIR_BUS\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Next, we get from which bus each circuit starts and which bus it goes to with get_map:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"cir2bus_to = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no1\")\ncir2bus_from = PSRI.get_map(data, \"PSRSerie\", \"PSRBus\", \"no2\")\n; nothing # hide","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"Now we can build the incidence matrix. Each row corresponds to a circuit and each column corresponds to a bus. The element at the index (i,j) is -1 if the circuit i starts from the bus j, 1 if it goes to this bus, and 0 if they both have no relation:","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\ncir_size = PSRI.max_elements(data, \"PSRSerie\")\nincidence_matrix = zeros(Float64, cir_size, bus_size)\nfor cir = 1:cir_size\n    incidence_matrix[cir, cir2bus_from[cir]] = -1.0\n    incidence_matrix[cir, cir2bus_to[cir]] = 1.0\nend\nincidence_matrix","category":"page"},{"location":"examples/reading_relations/","page":"Reading Relations","title":"Reading Relations","text":"","category":"page"},{"location":"openstudy_files/psrclasses/#psrclasses.json-and-Defaults","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"","category":"section"},{"location":"openstudy_files/psrclasses/","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"The psrclasses.json file stores the data from the OpenStudy model.","category":"page"},{"location":"openstudy_files/psrclasses/","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"It has the following structure:","category":"page"},{"location":"openstudy_files/psrclasses/","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"{\n    \"CustomCollection\": {\n        \"AVId\": \"string\",\n        \"name\": \"name\",\n        \"code\": 0,\n        \"Values\": [\n            0.0\n        ],\n        \"Cost\": 1.5\n    },\n    \"SecondCollection\": {\n        \"AVId\": \"string2\",\n        \"name\": \"name2\",\n        \"Type\": 3,\n        \"Generation(1)\": [\n            0.0,2.0\n        ],\n        \"Generation(2)\": [\n            5.0,3.0\n        ],\n        \"code\":1\n    }\n}\n","category":"page"},{"location":"openstudy_files/psrclasses/","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"note: Note\nIn the SecondCollection there are two parameters Generation(1) and Generation(2). They represent the values for the parameter Generation in two different dimensions.","category":"page"},{"location":"openstudy_files/psrclasses/#Defaults","page":"psrclasses.json and Defaults","title":"Defaults","text":"","category":"section"},{"location":"openstudy_files/psrclasses/","page":"psrclasses.json and Defaults","title":"psrclasses.json and Defaults","text":"The defaults.json file stores the default values for the parameters in the PSRI study. It has the same structure as the psrclasses.json. It is not a mandatory file, but it can be useful for the case when there are missing parameters for an element being created.","category":"page"},{"location":"psrdatabasesqlite/time_series/#Time-Series","page":"Time Series","title":"Time Series","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"It is possible to store time series data in your database. Time series in PSRDatabaseSQLite are very flexible. You can have missing values, and you can have sparse data. ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"There is a specific table format that must be followed. Consider the following example:","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL\n) STRICT;\n\nCREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"It is mandatory for a time series to be indexed by a date_time column with the following format: YYYY-MM-DD HH:MM:SS. You can use the Dates.jl package for handling this format.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"using Dates\ndate = DateTime(2024, 3, 1) # 2024-03-01T00:00:00 (March 1st, 2024)","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"Notice that in this example, there are two value columns some_vector1 and some_vector2. You can have as many value columns as you want. You can also separate the time series data into different tables, by creating a table Resource_time_series_group2 for example.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to add more dimensions to your time series, such as block and scenario.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource_time_series_group2 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    block INTEGER NOT NULL,\n    some_vector3 REAL,\n    some_vector4 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time, block)\n) STRICT; ","category":"page"},{"location":"psrdatabasesqlite/time_series/#Rules","page":"Time Series","title":"Rules","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"Time series in PSRDatabaseSQLite are very flexible. You can have missing values, and you can have sparse data. ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"If you are querying for a time series row entry that has a missing value, it first checks if there is a data with a date_time earlier than the queried date_time. If there is, it returns the value of the previous data. If there is no data earlier than the queried date_time, it returns a specified value according to the type of data you are querying.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"For Float64, it returns NaN.\nFor Int64, it returns typemin(Int).\nFor String, it returns \"\" (empty String).\nFor DateTime, it returns typemin(DateTime).","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"For example, if you have the following data:","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"Date some_vector1(Float64) some_vector2(Float64)\n2020 1.0 missing\n2021 missing 1.0\n2022 3.0 missing","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"If you query for some_vector1 at 2020, it returns 1.0. \nIf you query for some_vector2 at 2020, it returns NaN. \nIf you query for some_vector1 at 2021, it returns 1.0. \nIf you query for some_vector2 at 2021, it returns 1.0. \nIf you query for some_vector1 at 2022, it returns 3.0. \nIf you query for some_vector2 at 2022, it returns 1.0.","category":"page"},{"location":"psrdatabasesqlite/time_series/#Inserting-data","page":"Time Series","title":"Inserting data","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"When creating a new element that has a time series, you can pass this information via a DataFrame. Consider the collection Resource with the two time series tables Resource_time_series_group1 and Resource_time_series_group2.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"using DataFrames\nusing Dates\nusing PSRClassesInterface\nPSRDatabaseSQLite = PSRClassesInterface.PSRDatabaseSQLite\n\ndb = PSRDatabaseSQLite.create_empty_db_from_schema(db_path, path_schema; force = true)\n\nPSRDatabaseSQLite.create_element!(db, \"Configuration\"; label = \"Toy Case\", value1 = 1.0)\n\ndf_group1 = DataFrame(;\n        date_time = [DateTime(2000), DateTime(2001), DateTime(2002)],\n        some_vector1 = [missing, 1.0, 2.0],\n        some_vector2 = [1.0, missing, 5.0],\n    )\n\ndf_group2 = DataFrame(;\n            date_time = [\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2000),\n                DateTime(2001),\n                DateTime(2001),\n                DateTime(2001),\n                DateTime(2009),\n            ],\n            block = [1, 1, 1, 1, 2, 2, 2, 2],\n            some_vector3 = [1.0, 2.0, 3.0, 4.0, 1, 2, 3, 4],\n            some_vector4 = [1.0, 2.0, 3.0, 4.0, 1, 2, 3, 4],\n        )\n\n\nPSRDatabaseSQLite.create_element!(\n    db,\n    \"Resource\";\n    label = \"Resource 1\",\n    group1 = df_group1,\n    group2 = df_group2,\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to insert a single row of a time series. This is useful when you want to insert a specific dimension entry. This way of inserting time series is less efficient than inserting a whole DataFrame.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"using DataFrames\nusing Dates\nusing PSRClassesInterface\nPSRDatabaseSQLite = PSRClassesInterface.PSRDatabaseSQLite\n\ndb = PSRDatabaseSQLite.create_empty_db_from_schema(db_path, path_schema; force = true)\n\nPSRDatabaseSQLite.create_element!(db, \"Configuration\"; label = \"Toy Case\", value1 = 1.0)\n\nPSRDatabaseSQLite.create_element!(\n    db,\n    \"Resource\";\n    label = \"Resource 1\"\n)\n\nPSRDatabaseSQLite.add_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n    10.0; # new value\n    date_time = DateTime(2000)\n)\n\nPSRDatabaseSQLite.add_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n    11.0; # new value\n    date_time = DateTime(2001)\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/#Reading-data","page":"Time Series","title":"Reading data","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"You can read the information from the time series in two different ways.","category":"page"},{"location":"psrdatabasesqlite/time_series/#Reading-as-a-table","page":"Time Series","title":"Reading as a table","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"First, you can read the whole time series table for a given value, as a DataFrame.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"df = PSRDatabaseSQLite.read_time_series_table(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    \"Resource 1\",\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/#Reading-a-single-row","page":"Time Series","title":"Reading a single row","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"It is also possible to read a single row of the time series in the form of an array. This is useful when you want to query a specific dimension entry. For this function, there are performance improvements when reading the data via caching the previous and next non-missing values. ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"values = PSRDatabaseSQLite.read_time_series_row(\n    db,\n    \"Resource\",\n    \"some_vector1\",\n    Float64;\n    date_time = DateTime(2020)\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"When querying a row, all values should non-missing. However, if there is a missing value, the function will return the previous non-missing value. And if even the previous value is missing, it will return a specified value according to the type of data you are querying.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"For Float64, it returns NaN.\nFor Int64, it returns typemin(Int).\nFor String, it returns \"\" (empty String).\nFor DateTime, it returns typemin(DateTime).","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"For example, if you have the following data for the time series some_vector1:","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"Date Resource 1 Resource 2\n2020 1.0 missing\n2021 missing 1.0\n2022 3.0 missing","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"If you query at 2020, it returns [1.0, NaN]. \nIf you query at 2021, it returns [1.0, 1.0]. \nIf you query at 2022, it returns [3.0, 1.0]. ","category":"page"},{"location":"psrdatabasesqlite/time_series/#Updating-data","page":"Time Series","title":"Updating data","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"When updating one of the entries of a time series for a given element and attribute, you need to specify the exact dimension values of the row you want to update. ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"For example, consider a time series that has block and data_time dimensions.","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"PSRDatabaseSQLite.update_time_series_row!(\n    db,\n    \"Resource\",\n    \"some_vector3\",\n    \"Resource 1\",\n    10.0; # new value\n    date_time = DateTime(2000),\n    block = 1\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/#Deleting-data","page":"Time Series","title":"Deleting data","text":"","category":"section"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"You can delete the whole time series of an element for a given time series group. Consider the following table:","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"CREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"This table represents a \"group\" that stores two time series some_vector1 and some_vector2. You can delete all the data from this group by calling the following function:","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"PSRDatabaseSQLite.delete_time_series!(\n    db,\n    \"Resource\",\n    \"group1\",\n    \"Resource 1\",\n)","category":"page"},{"location":"psrdatabasesqlite/time_series/","page":"Time Series","title":"Time Series","text":"When trying to read a time series that has been deleted, the function will return an empty DataFrame.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PSRClassesInterface module provides interfaces to access data structured by PSR to be used in its models. Currently there are two main interfaces. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interface for studies. This interface is designed to read parameters from the files, some examples are deficit costs, fuel costs, currency, storage capacity etc.\nThe interface for reading and writing time series data. Time series data in the context of most studies have 4 dimensions (agents, stages, scenarios and blocks). Since studies of renewables with multiple agents, scenarios and stages can get quite big, we have designed different formats that are optimized to some objective (human readability, size, fast reading and writing, etc.).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both interfaces are defined as a set of methods that need to be implemented to make a different file format work. In this manual we will describe the abstract methods and give concrete examples of code to perform the work needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When using the PSRClassesInterface package in your codebase we strongly advise you to create a constant PSRI to keep the code concise and explicitly declare that a certain function came from PSRClassesInterface. This can be done by adding the following code to the top of the code","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface","category":"page"},{"location":"manual/#Initialize-Study","page":"Manual","title":"Initialize Study","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractData\nPSRClassesInterface.AbstractStudyInterface\nPSRClassesInterface.load_study\nPSRClassesInterface.description\nPSRClassesInterface.max_elements","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractData","page":"Manual","title":"PSRClassesInterface.AbstractData","text":"AbstractData\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.AbstractStudyInterface","page":"Manual","title":"PSRClassesInterface.AbstractStudyInterface","text":"AbstractStudyInterface\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.load_study","page":"Manual","title":"PSRClassesInterface.load_study","text":"load_study(::AbstractStudyInterface; kwargs...)\n\nInitialize all data structures of the study.\n\nnote: Differences between the OpenInterface and ClassicInterface\nEach study interface has its own set of kwargs... The easiest way to inspect the current available options is searching for this function on the Github repo of the desired interface.\n\nExample:\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface();\n    data_path = PATH_CASE_EXAMPLE_BATTERIES,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.description","page":"Manual","title":"PSRClassesInterface.description","text":"description(data::AbstractData)\n\nReturns the study description if available.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_elements","page":"Manual","title":"PSRClassesInterface.max_elements","text":"max_elements(data::AbstractData, collection::String)\n\nReturns an Int32 with the maximum number of elements for a given collection.\n\nExample:\n\nPSRI.max_elements(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-dimensions","page":"Manual","title":"Study dimensions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.StageType\nPSRClassesInterface.total_stages\nPSRClassesInterface.total_scenarios\nPSRClassesInterface.total_blocks\nPSRClassesInterface.total_openings\nPSRClassesInterface.total_stages_per_year","category":"page"},{"location":"manual/#PSRClassesInterface.StageType","page":"Manual","title":"PSRClassesInterface.StageType","text":"PSRI.StageType\n\nPossible stage types used in for reading and writing time series files.\n\nThe current possible stage types are:\n\nSTAGE_UNKNOWN\nSTAGE_WEEK\nSTAGE_MONTH\nSTAGE_3MONTHS\nSTAGE_HOUR\nSTAGE_DAY\nSTAGE_13MONTHS\nSTAGE_2MONTHS\nSTAGE_4MONTHS\nSTAGE_6MONTHS\nSTAGE_YEAR\nSTAGE_DECADE\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.total_stages","page":"Manual","title":"PSRClassesInterface.total_stages","text":"total_stages(data::AbstractData)\n\nReturns the total number of stages of the case.\n\nExample:\n\nPSRI.total_stages(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_scenarios","page":"Manual","title":"PSRClassesInterface.total_scenarios","text":"total_scenarios(data::AbstractData)\n\nReturns the total number of scenarios of the case.\n\nExample:\n\nPSRI.total_scenarios(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_blocks","page":"Manual","title":"PSRClassesInterface.total_blocks","text":"total_blocks(data::AbstractData)\n\nReturns the total number of blocks of the case.\n\nExample:\n\nPSRI.total_blocks(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_openings","page":"Manual","title":"PSRClassesInterface.total_openings","text":"total_openings(data::AbstractData)\n\nReturns the total number of openings of the case.\n\nExample:\n\nPSRI.total_openings(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.total_stages_per_year","page":"Manual","title":"PSRClassesInterface.total_stages_per_year","text":"total_stages_per_year(data::AbstractData)\n\nReturns the total number of stages per year of the case.\n\nExample:\n\nPSRI.total_stages_per_year(data)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Study-duration-and-blocking","page":"Manual","title":"Study duration and blocking","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.BlockDurationMode\nPSRClassesInterface.stage_duration\nPSRClassesInterface.block_duration\nPSRClassesInterface.block_from_stage_hour","category":"page"},{"location":"manual/#Read-Scalar-Attributes","page":"Manual","title":"Read Scalar Attributes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.configuration_parameter\nPSRClassesInterface.get_code\nPSRClassesInterface.get_name\nPSRClassesInterface.get_parm\nPSRClassesInterface.get_parm_1d\nPSRClassesInterface.get_parms\nPSRClassesInterface.get_parms_1d","category":"page"},{"location":"manual/#PSRClassesInterface.configuration_parameter","page":"Manual","title":"PSRClassesInterface.configuration_parameter","text":"configuration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::T\n) where T <: MainTypes\n\nReturns the required configuration parameter from the case. If the parameter is not registered returns the default value.\n\nconfiguration_parameter(\n    data::AbstractData,\n    attribute::String,\n    default::Vector{T},\n) where T <: MainTypes\n\nReturns the rquired configuration parameters from the case that are vectors that are vectors. If the parameter is not registered returns the default value.\n\nExamples:\n\nPSRI.configuration_parameter(data, \"MaximoIteracoes\", 0)\nPSRI.configuration_parameter(data, \"MinOutflowPenalty\", 0.0)\n\nPSRI.configuration_parameter(data, \"DeficitCost\", [0.0])\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_code","page":"Manual","title":"PSRClassesInterface.get_code","text":"get_code(data::AbstractData, collection::String)\n\nReturns a Vector{Int32} containing the code of each element in collection.\n\nExample:\n\nPSRI.get_code(data, \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_name","page":"Manual","title":"PSRClassesInterface.get_name","text":"get_name(data::AbstractData, collection::String)\n\nReturns a Vector{String} containing the name of each element in collection.\n\nExample:\n\nPSRI.get_name(data, \"PSRThermalPlant\")\nPSRI.get_name(data, \"PSRGaugingStation\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm","page":"Manual","title":"PSRClassesInterface.get_parm","text":"get_parm(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm(data, \"PSRBattery\", \"Einic\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"ChargeRamp\", Float64, 1)\nPSRI.get_parm(data, \"PSRBattery\", \"DischargeRamp\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parm_1d","page":"Manual","title":"PSRClassesInterface.get_parm_1d","text":"get_parm_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a T containing the the value from attribute of collection. This function is used to get data from collections that don't vary over time.\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64, 1)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms","page":"Manual","title":"PSRClassesInterface.get_parms","text":"get_parms(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    validate::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parms(data, \"PSRBattery\", \"Einic\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"ChargeRamp\", Float64)\nPSRI.get_parms(data, \"PSRBattery\", \"DischargeRamp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_parms_1d","page":"Manual","title":"PSRClassesInterface.get_parms_1d","text":"get_parms_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    validate::Bool = true,\n    ignore::Bool = false,\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} containing the elements in collection to a vector in julia. This function is used to get data from collections that don't vary over time\n\nExample:\n\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP\", Float64)\nPSRI.get_parm_1d(data, \"PSRHydroPlant\", \"FP.VOL\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-Vector-Attributes","page":"Manual","title":"Read Vector Attributes","text":"","category":"section"},{"location":"manual/#Time-controller","page":"Manual","title":"Time controller","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.mapped_vector\nPSRClassesInterface.go_to_stage\nPSRClassesInterface.go_to_dimension\nPSRClassesInterface.update_vectors!","category":"page"},{"location":"manual/#PSRClassesInterface.mapped_vector","page":"Manual","title":"PSRClassesInterface.mapped_vector","text":"mapped_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n    dim1::String=\"\",\n    dim2::String=\"\";\n    ignore::Bool=false,\n    map_key = collection, # reference for PSRMap pointer, if empty use class name\n    filters = String[], # for calling just within a subset instead of the full call\n) where T\n\nMaps a Vector{T} containing the elements in collection to a vector in julia. When the function update_vectors! is called the elements of the vector will be updated to the according elements registered at the current data.time_controller.\n\nExample:\n\nexisting = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"Existing\", Int32)\npot_inst = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"PotInst\", Float64)\n\nFor more information please read the example Reading basic thermal generator parameters\n\nnote: Differences between the OpenInterface and ClassicInterface\nWhen using mapped_vector in the OpenInterface mode the vector will be mapped with the correct values at first hand. When using mapped_vector in the ClassicInterface mode you should call update_vectors! to get the good values for the collection, otherwise you might only get a vector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_stage","page":"Manual","title":"PSRClassesInterface.go_to_stage","text":"go_to_stage(data::AbstractData, stage::Integer)\n\nGoes to the stage in the data time controller.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.go_to_dimension","page":"Manual","title":"PSRClassesInterface.go_to_dimension","text":"go_to_dimension(data::AbstractData, name::String, value::Integer)\n\nMoves time controller reference of vectors indexed by dimension name to the index value.\n\nExample:\n\ncesp = PSRI.mapped_vector(data, \"PSRThermalPlant\", \"CEsp\", Float64, \"segment\", \"block\")\n\nPSRI.go_to_stage(data, 1)\n\nPSRI.go_to_dimension(data, \"segment\", 1)\nPSRI.go_to_dimension(data, \"block\", 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.update_vectors!","page":"Manual","title":"PSRClassesInterface.update_vectors!","text":"update_vectors!(data::AbstractData)\n\nUpdate all mapped vectors according to the time controller inside data.\n\nupdate_vectors!(data::AbstractData, filters::Vector{String})\n\nUpdate filtered classes of mapped vectors according to the time controller inside data.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Direct-access","page":"Manual","title":"Direct access","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_vector\nPSRClassesInterface.get_vector_1d\nPSRClassesInterface.get_vector_2d\nPSRClassesInterface.get_vectors\nPSRClassesInterface.get_vectors_1d\nPSRClassesInterface.get_vectors_2d\nPSRClassesInterface.get_nonempty_vector\nPSRClassesInterface.get_series","category":"page"},{"location":"manual/#PSRClassesInterface.get_vector","page":"Manual","title":"PSRClassesInterface.get_vector","text":"PSRI.get_vector(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{T} of entries of the attribute of collection at the element with index index.\n\nExample:\n\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Vazao\", 1, Float64)\nPSRI.get_vector(data, \"PSRGaugingStation\", \"Data\", 1, Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_1d","page":"Manual","title":"PSRClassesInterface.get_vector_1d","text":"PSRI.get_vector_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection at the element with index index. The outer vector contains one entry per index in dimension 1, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_1d(data, \"PSRArea\", \"Export\", 1, Float64)\nPSRI.get_vector_1d(data, \"PSRLoad\", \"P\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_2d","page":"Manual","title":"PSRClassesInterface.get_vector_2d","text":"PSRI.get_vector_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Matrix{Vector{T}} of entries of the attribute of collection at the element with index index. The outer matrix contains one entry per index in dimension 1 and dimension 2, while the inner vector is sized according to the main vector index which is tipicaaly time.\n\nExample:\n\nPSRI.get_vector_2d(data, \"PSRThermalPlant\", \"CEsp\", 1, Float64)\nPSRI.get_vector_2d(data, \"PSRFuelConsumption\", \"CEsp\", 1, Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors","page":"Manual","title":"PSRClassesInterface.get_vectors","text":"PSRI.get_vectors(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T};\n    default::T = _default_value(T),\n) where T\n\nReturns a Vector{Vector{T}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection.\n\nExample:\n\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Vazao\", Float64)\nPSRI.get_vectors(data, \"PSRGaugingStation\", \"Data\", Dates.Date)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_1d","page":"Manual","title":"PSRClassesInterface.get_vectors_1d","text":"PSRI.get_vectors_1d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Vector{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the 2 inner vectors see get_vector_1d.\n\nExample:\n\nPSRI.get_vectors_1d(data, \"PSRArea\", \"Export\", Float64)\nPSRI.get_vectors_1d(data, \"PSRLoad\", \"P\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vectors_2d","page":"Manual","title":"PSRClassesInterface.get_vectors_2d","text":"PSRI.get_vectors_2d(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n    ::Type{T},\n) where T\n\nReturns a Vector{Matrix{Vector{T}}} of entries of the attribute of collection. Each entry of the outer vector corresponding to an element of the collection. For the containt of the Matrix{Vector{T}} see get_vector_2d.\n\nExample:\n\nPSRI.get_vectors_2d(data, \"PSRThermalPlant\", \"CEsp\", Float64)\nPSRI.get_vectors_2d(data, \"PSRFuelConsumption\", \"CEsp\", Float64)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_nonempty_vector","page":"Manual","title":"PSRClassesInterface.get_nonempty_vector","text":"get_nonempty_vector(\n    data::AbstractData,\n    colllection::String,\n    attribute::String,\n)\n\nReturns a vector of booleans with the number of elements of the collection. true means the vector associated with the given attribute is non-emepty, false means it is empty.\n\nExample:\n\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"ChroGerMin\")\nPSRI.get_nonempty_vector(data, \"PSRThermalPlant\", \"SpinningReserve\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_series","page":"Manual","title":"PSRClassesInterface.get_series","text":"function get_series(\n    data::Data,\n    collection::String,\n    indexing_attribute::String,\n    index::Int,\n)\n\nRetrieves a SeriesTable object with all attributes from an element that are indexed by index_attr.\n\nExample\n\njulia> PSRI.get_series(data, \"PSRThermalPlant\", \"Data\", 1)\nDict{String, Vector} with 13 entries:\n  \"GerMin\"   => [0.0]\n  \"GerMax\"   => [888.0]\n  \"NGas\"     => [nothing]\n  \"IH\"       => [0.0]\n  \"ICP\"      => [0.0]\n  \"Data\"     => [\"1900-01-01\"]\n  \"CoefE\"    => [1.0]\n  \"PotInst\"  => [888.0]\n  \"Existing\" => [0]\n  \"sfal\"     => [0]\n  \"NAdF\"     => [0]\n  \"Unidades\" => [1]\n  \"StartUp\"  => [0.0]\n\n\n\n\n\n","category":"function"},{"location":"manual/#Relations-between-collections","page":"Manual","title":"Relations between collections","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.RelationType\nPSRClassesInterface.is_vector_relation\nPSRClassesInterface.get_references\nPSRClassesInterface.get_vector_references\nPSRClassesInterface.get_map\nPSRClassesInterface.get_vector_map\nPSRClassesInterface.get_reverse_map\nPSRClassesInterface.get_reverse_vector_map\nPSRClassesInterface.get_related\nPSRClassesInterface.get_vector_related","category":"page"},{"location":"manual/#PSRClassesInterface.is_vector_relation","page":"Manual","title":"PSRClassesInterface.is_vector_relation","text":"is_vector_relation(relation::PSRI.PMD.RelationType)\n\nReturns true is relation is a vector relation.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_references","page":"Manual","title":"PSRClassesInterface.get_references","text":"get_references(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    relation_type::RelationType = RELATION_1_TO_1, # type of the direct relation\n)\n\nRetrurn a Vector{String} with the references between collections given a certain RelationType.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_references","page":"Manual","title":"PSRClassesInterface.get_vector_references","text":"get_vector_references(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    relation_type::RelationType = RELATION_1_TO_N, # type of the direct relation\n)\n\nRetrurn a Vector{Vector{String}} with the references between collections given a certain RelationType.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_map","page":"Manual","title":"PSRClassesInterface.get_map","text":"get_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    allow_empty::Bool = true,\n    relation_type::RelationType = RELATION_1_TO_1, # type of the direct relation\n)\n\nReturns a Vector{Int32} with the map between collections given a certain RelationType. If the map is a vector [3, 2, 1] it means that the element 1 of lst_from is related to the element 3 of lst_to. If the relation does not exist it might return -1 or some garbage value.\n\nExamples:\n\nPSRI.get_map(data, \"PSRBattery\", \"PSRSystem\")\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRThermalPlant\")\n\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_SPILL_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_INFILTRATE_TO,\n)\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_STORED_ENERGY_DONWSTREAM,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_map","page":"Manual","title":"PSRClassesInterface.get_vector_map","text":"get_vector_map(\n    data::AbstractData,\n    collection_from::String,\n    collection_to::String;\n    relation_type::RelationType = RELATION_1_TO_N,\n)\n\nReturns a Vector{Vector{Int32}} to represent the relation between each element of collection_from to multiple elements of collection_to.\n\nSince multiple relations might be available one might need to specify relation_type.\n\nExample:\n\nPSRI.get_vector_map(data, \"PSRInterconnectionSumData\", \"PSRInterconnection\")\nPSRI.get_vector_map(data, \"PSRReserveGenerationConstraintData\", \"PSRHydroPlant\")\nPSRI.get_vector_map(\n    data,\n    \"PSRReserveGenerationConstraintData\",\n    \"PSRThermalPlant\";\n    relation_type = PSRI.PMD.RELATION_BACKED,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_map","page":"Manual","title":"PSRClassesInterface.get_reverse_map","text":"get_reverse_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_1,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Int32} with the relation reversed. Some relations cannot be reversed this way since they are not bijections, in this case use get_reverse_vector_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\nPSRI.get_reverse_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n# which is te reverse of\nPSRI.get_map(data, \"PSRMaintenanceData\", \"PSRHydroPlant\")\n\nPSRI.get_reverse_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRThermalPlant\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_reverse_vector_map","page":"Manual","title":"PSRClassesInterface.get_reverse_vector_map","text":"get_reverse_vector_map(\n    data::AbstractData,\n    lst_from::String,\n    lst_to::String;\n    original_relation_type::RelationType = RELATION_1_TO_N,\n)\n\nObtains the relation between lst_from and lst_to though original_relation_type. But returns a Vector{Vector{Int32}} with the relation reversed.\n\nSome relations are bijections, in these cases it is also possible to use use get_reverse_map.\n\nSee also get_map, get_vector_map, get_reverse_vector_map.\n\nExample:\n\n# upstream turbining hydros\nPSRI.get_reverse_vector_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    original_relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\n# which is the reverse of\nPSRI.get_map(\n    data,\n    \"PSRHydroPlant\",\n    \"PSRHydroPlant\";\n    relation_type = PSRI.PMD.RELATION_TURBINE_TO,\n)\n\nPSRI.get_reverse_vector_map(\n    data,\n    \"PSRGenerator\",\n    \"PSRBus\";\n    original_relation_type = PSRI.PMD.RELATION_1_TO_1,\n)\n# which is the reverse of\nPSRI.get_map(data, \"PSRGenerator\", \"PSRBus\")\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_related","page":"Manual","title":"PSRClassesInterface.get_related","text":"get_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_1,\n)\n\nReturns the index of the element in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_vector_related","page":"Manual","title":"PSRClassesInterface.get_vector_related","text":"get_vector_related(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    relation_type = RELATION_1_TO_N,\n)\n\nReturns the vector of indices of the elements in collection target related to the element in the collection source element indexed by source_index according to the scalar relation relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reflection","page":"Manual","title":"Reflection","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.get_attribute_dim1\nPSRClassesInterface.get_attribute_dim2\nPSRClassesInterface.get_collections\nPSRClassesInterface.get_attributes\nPSRClassesInterface.get_attribute_struct\nPSRClassesInterface.get_data_struct\nPSRClassesInterface.Attribute\nPSRClassesInterface.get_attributes_indexed_by\nPSRClassesInterface.get_relations\nPSRClassesInterface.get_attribute_dim","category":"page"},{"location":"manual/#PSRClassesInterface.get_attribute_dim1","page":"Manual","title":"PSRClassesInterface.get_attribute_dim1","text":"get_attribute_dim1(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 1 of attribute from collection at element index. Errors if attribute has zero dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim2","page":"Manual","title":"PSRClassesInterface.get_attribute_dim2","text":"get_attribute_dim2(\n    data::AbstractData,\n    collection::String,\n    attribute::string,\n    index::Integer;\n)\n\nReturns the size of dimension 2 of attribute from collection at element index. Errors if attribute has zero or one dimensions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_collections","page":"Manual","title":"PSRClassesInterface.get_collections","text":"get_collections(data::AbstractData)\n\nReturn Vector{String} of valid collections (depends on loaded pmd files).\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attributes","page":"Manual","title":"PSRClassesInterface.get_attributes","text":"get_attributes(data::AbstractData, collection::String)\n\nReturn Vector{String} of valid attributes from collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_struct","page":"Manual","title":"PSRClassesInterface.get_attribute_struct","text":"get_attribute_struct(\n    data::AbstractData,\n    collection::String,\n    attribute::String,\n)\n\nReturns a struct of type Attribute with fields:\n\nname::String = attribute name\nis_vector::Bool = true if attribute is a vector (tipically, varies in time)\ntype::DataType = attribute type (tipically: Int32, Float64, String, Dates.Date)\ndim::Int = number of additional dimensions\nindex::String = if a vector represents the indexing vector (might be empty)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_data_struct","page":"Manual","title":"PSRClassesInterface.get_data_struct","text":"get_attribute_struct(data::AbstractData)\n\nReturn a struct of type DataStruct with collection names (strings) as keys and maps from attributes names (string) to attributes data definitions Attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.Attribute","page":"Manual","title":"PSRClassesInterface.Attribute","text":"struct Attribute\n    name::String\n    is_vector::Bool\n    type::DataType\n    dim::Int\n    index::String\nend\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.get_attributes_indexed_by","page":"Manual","title":"PSRClassesInterface.get_attributes_indexed_by","text":"get_attributes_indexed_by(\n    data::AbstractData,\n    collection::String,\n    indexing_attribute::String\n)\n\nReturn Vector{String} of valid vector attributes from collection that are indexed by indexing_attribute.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_relations","page":"Manual","title":"PSRClassesInterface.get_relations","text":"get_relations(data::AbstractData, collection::String)\n\nReturns a Tuple{String, Vector{PMD.Relation}} with relating collection and their relation type associated to collection.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.get_attribute_dim","page":"Manual","title":"PSRClassesInterface.get_attribute_dim","text":"get_attribute_dim(attribute_struct::Attribute)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-and-Write-Graf-files","page":"Manual","title":"Read and Write Graf files","text":"","category":"section"},{"location":"manual/#Open-and-Close","page":"Manual","title":"Open and Close","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.AbstractReader\nPSRClassesInterface.AbstractWriter\nPSRClassesInterface.open\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.AbstractReader","page":"Manual","title":"PSRClassesInterface.AbstractReader","text":"PSRI.AbstractReader\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.AbstractWriter","page":"Manual","title":"PSRClassesInterface.AbstractWriter","text":"PSRI.AbstractWriter\n\n\n\n\n\n","category":"type"},{"location":"manual/#PSRClassesInterface.open","page":"Manual","title":"PSRClassesInterface.open","text":"PSRI.open(::Type{<:AbstractWriter}, path::String; kwargs...)\n\nMethod for opening file and registering time series data. If specified file doesn't exist, the method will create it, otherwise, the previous one will be overwritten. Returns updated AbstractWriter instance.\n\nArguments:\n\nwriter: AbstractWriter instance to be used for opening file.\npath: path to file.\n\nKeyword arguments:\n\nblocks: case's number of blocks.\nscenarios: case's number of scenarios.\nstages: case's number of stages.\nagents: list of element names.\nunit: dimension of the elements' data.\nis_hourly: if data is hourly. If yes, block dimension will be ignored.\nhour_discretization: sub-hour parameter to discretize an hour into minutes.\nname_length: length of element names.\nblock_type: case's type of block.\nscenarios_type: case's type of scenario.\nstage_type: case's type of stage.\ninitial_stage: stage at which to start registry.\ninitial_year: year at which to start registry.\nallow_unsafe_name_length: allow element names outside safety bounds.\n\nExamples:\n\nWriting and reading a time series into a file\n\nPSRI.open(reader::Type{<:AbstractReader}, path::String; kwargs...)\n\nMethod for opening file and reading time series data. Returns updated AbstractReader instance.\n\nArguments:\n\nreader::Type{<:AbstractReader}: AbstractReader instance to be used for opening file.\npath::String: path to file.\n\nKeyword arguments:\n\nis_hourly::Bool: if data to be read is hourly, other than blockly.\nstage_type::PSRI.StageType: the PSRClassesInterface.StageType of the data, defaults to PSRI.STAGE_MONTH.\nheader::Vector{String}: if file has a header with metadata.\nuse_header::Bool: if data from header should be retrieved.\nfirst_stage::Dates.Date: stage at which start reading.\nverbose_header::Bool: if data from header should be displayed during execution.\n\nExamples:\n\nWriting and reading a time series into a file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.close","page":"Manual","title":"PSRClassesInterface.close","text":"PSRI.close(ior::AbstractReader)\n\nCloses the PSRClassesInterface.AbstractReader instance.\n\n\nPSRI.close(iow::AbstractWriter)\n\nCloses the PSRClassesInterface.AbstractWriter instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-entire-file","page":"Manual","title":"Write entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.array_to_file","category":"page"},{"location":"manual/#PSRClassesInterface.array_to_file","page":"Manual","title":"PSRClassesInterface.array_to_file","text":"PSRI.array_to_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#Write-registry","page":"Manual","title":"Write registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.write_registry","category":"page"},{"location":"manual/#PSRClassesInterface.write_registry","page":"Manual","title":"PSRClassesInterface.write_registry","text":"PSRI.write_registry(\n    iow::AbstractWriter,\n    data::Vector{T},\n    stage::Integer,\n    scenario::Integer = 1,\n    block::Integer = 1,\n) where T <: Real\n\nWrites a data row into opened file through PSRClassesInterface.AbstractWriter instance.\n\nArguments:\n\niow: PSRI.AbstractWriter instance to be used for accessing file.\ndata: elements data to be written.\nstage: stage of the data to be written.\nscenario: scenarios of the data to be written.\nblock: block of the data to be written.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Header-information","page":"Manual","title":"Header information","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.is_hourly\nPSRClassesInterface.hour_discretization\nPSRClassesInterface.max_stages\nPSRClassesInterface.max_scenarios\nPSRClassesInterface.max_blocks\nPSRClassesInterface.max_blocks_current\nPSRClassesInterface.max_blocks_stage\nPSRClassesInterface.max_agents\nPSRClassesInterface.stage_type\nPSRClassesInterface.initial_stage\nPSRClassesInterface.initial_year\nPSRClassesInterface.data_unit\nPSRClassesInterface.agent_names","category":"page"},{"location":"manual/#PSRClassesInterface.is_hourly","page":"Manual","title":"PSRClassesInterface.is_hourly","text":"PSRI.is_hourly(ior::AbstractReader)\n\nReturns a Bool indicating whether the data in the file read by PSRClassesInterface.AbstractReader is hourly.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.hour_discretization","page":"Manual","title":"PSRClassesInterface.hour_discretization","text":"PSRI.hour_discretization(ior::AbstractReader)\n\nReturns an Int indicating the hour discretization.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_stages","page":"Manual","title":"PSRClassesInterface.max_stages","text":"PSRI.max_stages(ior::AbstractReader)\n\nReturns an Int indicating maximum number of stages in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_scenarios","page":"Manual","title":"PSRClassesInterface.max_scenarios","text":"PSRI.max_scenarios(ior::AbstractReader)\n\nReturns an Int indicating maximum number of scenarios in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks","page":"Manual","title":"PSRClassesInterface.max_blocks","text":"PSRI.max_blocks(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_current","page":"Manual","title":"PSRClassesInterface.max_blocks_current","text":"PSRI.max_blocks_current(ior::AbstractReader)\n\nReturns an Int indicating maximum number of blocks in the cuurent stage in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_blocks_stage","page":"Manual","title":"PSRClassesInterface.max_blocks_stage","text":"PSRI.max_blocks_stage(ior::AbstractReader, t::Integer)\n\nReturns an Int indicating maximum number of blocks in the stage t in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.max_agents","page":"Manual","title":"PSRClassesInterface.max_agents","text":"PSRI.max_agents(ior::AbstractReader)\n\nReturns an Int indicating maximum number of agents in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.stage_type","page":"Manual","title":"PSRClassesInterface.stage_type","text":"stage_type\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_stage","page":"Manual","title":"PSRClassesInterface.initial_stage","text":"PSRI.initial_stage(ior::AbstractReader)\n\nReturns an Int indicating the initial stage in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.initial_year","page":"Manual","title":"PSRClassesInterface.initial_year","text":"PSRI.initial_year(ior::AbstractReader)\n\nReturns an Int indicating the initial year in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.data_unit","page":"Manual","title":"PSRClassesInterface.data_unit","text":"PSRI.data_unit(ior::AbstractReader)\n\nReturns a String indicating the unit of the data in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.agent_names","page":"Manual","title":"PSRClassesInterface.agent_names","text":"PSRI.agent_names(ior::AbstractReader)\n\nReturns a Vector{String} with the agent names in the file read by PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-entire-file","page":"Manual","title":"Read entire file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.file_to_array\nPSRClassesInterface.file_to_array_and_header","category":"page"},{"location":"manual/#PSRClassesInterface.file_to_array","page":"Manual","title":"PSRClassesInterface.file_to_array","text":"PSRI.file_to_array(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.file_to_array_and_header","page":"Manual","title":"PSRClassesInterface.file_to_array_and_header","text":"PSRI.file_to_array_and_header(::Type{T}, path::String; use_header::Bool = true, header::Vector{String} = String[]) where T <: AbstractReader\n\nWrite a file to an array and header\n\n\n\n\n\n","category":"function"},{"location":"manual/#Read-registry","page":"Manual","title":"Read registry","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.current_stage\nPSRClassesInterface.current_scenario\nPSRClassesInterface.current_block\nPSRClassesInterface.goto\nPSRClassesInterface.next_registry","category":"page"},{"location":"manual/#PSRClassesInterface.current_stage","page":"Manual","title":"PSRClassesInterface.current_stage","text":"PSRI.current_stage(ior::AbstractReader)\n\nReturns an Int indicating the current stage in the stream of the PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_scenario","page":"Manual","title":"PSRClassesInterface.current_scenario","text":"PSRI.current_scenario(ior::AbstractReader)\n\nReturns an Int indicating the current scenarios in the stream of the PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.current_block","page":"Manual","title":"PSRClassesInterface.current_block","text":"PSRI.current_block(ior::AbstractReader)\n\nReturns an Int indicating the current block in the stream of the PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.goto","page":"Manual","title":"PSRClassesInterface.goto","text":"PSRI.goto(\n    ior::AbstractReader, \n    t::Integer, \n    s::Integer = 1, \n    b::Integer = 1\n)\n\nGoes to the registry of the stage t, scenario s and block b.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.next_registry","page":"Manual","title":"PSRClassesInterface.next_registry","text":"PSRI.next_registry(ior::AbstractReader)\n\nGoes to the next registry on the PSRClassesInterface.AbstractReader.\n\n\n\n\n\n","category":"function"},{"location":"manual/#File-conversion","page":"Manual","title":"File conversion","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.convert_file\nPSRClassesInterface.add_reader!","category":"page"},{"location":"manual/#PSRClassesInterface.convert_file","page":"Manual","title":"PSRClassesInterface.convert_file","text":"convert_file\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.add_reader!","page":"Manual","title":"PSRClassesInterface.add_reader!","text":"add_reader!\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reader-mapper","page":"Manual","title":"Reader mapper","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.ReaderMapper\nPSRClassesInterface.add_reader!\n<!-- PSRClassesInterface.goto -->\nPSRClassesInterface.close","category":"page"},{"location":"manual/#PSRClassesInterface.ReaderMapper","page":"Manual","title":"PSRClassesInterface.ReaderMapper","text":"ReaderMapper{T}\n\n\n\n\n\n","category":"type"},{"location":"manual/#Modification-API","page":"Manual","title":"Modification API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PSRClassesInterface.create_study\nPSRClassesInterface.create_element!\nPSRClassesInterface.set_parm!\nPSRClassesInterface.set_vector!\nPSRClassesInterface.set_series!\nPSRClassesInterface.write_data\nPSRClassesInterface.set_related!\nPSRClassesInterface.set_vector_related!","category":"page"},{"location":"manual/#PSRClassesInterface.create_study","page":"Manual","title":"PSRClassesInterface.create_study","text":"create_study(::AbstractStudyInterface; kwargs...)\n\nReturns the Data object of a new study.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.create_element!","page":"Manual","title":"PSRClassesInterface.create_element!","text":"create_element!(\n    data::Data,\n    collection::String,\n    ps::Pair{String,<:Any};\n    default::Union{Dict{String,Any},Nothing} = nothing\n)\n\nCreates a new instance of the given collection and returns its index.\n\nExample:\n\nindex = PSRI.create_element!(data, \"PSRClass\")\n\nPSRI.set_parm!(data, \"PSRClass\", index, \"PSRAttr\", value)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_parm!","page":"Manual","title":"PSRClassesInterface.set_parm!","text":"set_parm!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Integer,\n    value::T,\n) where {T <: MainTypes}\n\nDefines the value of a scalar parameter.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector!","page":"Manual","title":"PSRClassesInterface.set_vector!","text":"function set_vector!(\n    data::Data,\n    collection::String,\n    attribute::String,\n    index::Int,\n    buffer::Vector{T}\n) where {T<:MainTypes}\n\nUpdates a data vector according to the given buffer. Note: Modifying current vector length is not allowed: use set_series! instead.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_series!","page":"Manual","title":"PSRClassesInterface.set_series!","text":"function set_series!(\n    data::Data,\n    collection::String,\n    index_attr::String,\n    index::Int,\n    buffer::Dict{String,Vector}\n)\n\nUpdates serial (indexed) data. All columns must be the same as before. The series length is allowed to be changed, but all vectors in the new series must have equal length.\n\njulia> series = Dict{String, Vector}(\n         \"GerMin\" => [0.0, 1.0],\n         \"GerMax\" => [888.0, 777.0],\n         \"NGas\" => [nothing, nothing],\n         \"IH\" => [0.0, 0.0],\n         \"CoefE\" => [1.0, 2.0],\n         \"PotInst\" => [888.0, 777.0],\n         \"ICP\" => [0.0, 0.0],\n         \"Data\" => [\"1900-01-01\", \"1900-01-02\"],\n         \"Existing\" => [0, 0],\n         \"sfal\" => [0, 1],\n         \"NAdF\" => [0, 0],\n         \"Unidades\" => [1, 1],\n         \"StartUp\" => [0.0, 2.0]\n       );\n\njulia> PSRI.set_series!(data, \"PSRThermalPlant\", 1, \"Data\", series)\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.write_data","page":"Manual","title":"PSRClassesInterface.write_data","text":"write_data(data::Data, path::String)\n\nWrites data to file in JSON format.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_related!","page":"Manual","title":"PSRClassesInterface.set_related!","text":"set_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Integer;\n    relation_type = RELATION_1_TO_1,\n)\n\nSets the element source_index from collection source to be related to the element target_index from collection target in the scalar relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"manual/#PSRClassesInterface.set_vector_related!","page":"Manual","title":"PSRClassesInterface.set_vector_related!","text":"set_vector_related!(\n    data::AbstractData,\n    source::String,\n    target::String,\n    source_index::Integer,\n    target_index::Vector{<:Integer};\n    relation_type = RELATION_1_TO_N,\n)\n\nSets the element source_index from collection source to be related to the elements in target_index from collection target in the vector relation of type relation_type.\n\n\n\n\n\n","category":"function"},{"location":"psrdatabasesqlite/introduction/#SQLite-101","page":"SQLite 101","title":"SQLite 101","text":"","category":"section"},{"location":"psrdatabasesqlite/introduction/","page":"SQLite 101","title":"SQLite 101","text":"SQLite is a software library that provides a relational database management system. The lite in SQLite means light weight in terms of setup, database administration, and required resource. SQLite does NOT require a server to run.","category":"page"},{"location":"psrdatabasesqlite/introduction/","page":"SQLite 101","title":"SQLite 101","text":"Although PSRI provides a simplified interface, similar to PSRI.OpenStudy, to read and write data in SQLite format, it is important to understand the basics of SQLite.","category":"page"},{"location":"psrdatabasesqlite/introduction/","page":"SQLite 101","title":"SQLite 101","text":"To learn the basics, we recommend the following resources:","category":"page"},{"location":"psrdatabasesqlite/introduction/","page":"SQLite 101","title":"SQLite 101","text":"SQLite Tutorial\nSQLite Documentation","category":"page"},{"location":"psrdatabasesqlite/introduction/","page":"SQLite 101","title":"SQLite 101","text":"tip: Tip\nWe recommend using SQLiteStudio to debug and visualize your SQLite database. You can download it here.","category":"page"},{"location":"openstudy_files/file_diagram/#OpenStudy-Files-and-Structs-101","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"","category":"section"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"When creating or loading a study using the OpenStudy framework, PSRI uses different files. This flowchart shows the order in which the files are used.","category":"page"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"The classes and their attributes are defined in a PMD file.\nThen, a Model Template file is used to map the classes to collections in the study.\nUsing the Model Template and the PMD file, the Data Struct file is created.\nPSRI loads the Data Struct, Relation Mapper and Defaults files into structs and create a study, whose data will be stored in a file named psrclasses.json.","category":"page"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"(Image: OpenStudy Diagram)","category":"page"},{"location":"openstudy_files/file_diagram/#How-the-structs-are-used","page":"OpenStudy Files and Structs 101","title":"How the structs are used","text":"","category":"section"},{"location":"openstudy_files/file_diagram/#Creating-an-element","page":"OpenStudy Files and Structs 101","title":"Creating an element","text":"","category":"section"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"When creating an element from a collection, OpenStudy uses the Data Struct, Relation Mapper and Defaults files to check if:","category":"page"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"The collection is defined in the Data Struct file.\nThe element has all the attributes defined in the Data Struct file.\nIn the case where the element does not have all the attributes, the Defaults file has the remaining ones.","category":"page"},{"location":"openstudy_files/file_diagram/#Creating-a-relation","page":"OpenStudy Files and Structs 101","title":"Creating a relation","text":"","category":"section"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"When creating a relation between two collections, OpenStudy uses the Relation Mapper to check if:","category":"page"},{"location":"openstudy_files/file_diagram/","page":"OpenStudy Files and Structs 101","title":"OpenStudy Files and Structs 101","text":"The relation is defined in the Relation Mapper\nThe elements exist in the study","category":"page"},{"location":"openstudy_files/relation_mapper/#Relation-Mapper","page":"Relation Mapper","title":"Relation Mapper","text":"","category":"section"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"If you have already checked the PMD manual, you know that a PMD file can define relations between models. When these relations are parsed, they are stored in a Julia dictionary, the Relation Mapper.","category":"page"},{"location":"openstudy_files/relation_mapper/#Relation-Mapper-JSON-file","page":"Relation Mapper","title":"Relation Mapper JSON file","text":"","category":"section"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"However, it is also possible to fill the Relation Mapper with a JSON file, that follows the same structure as OpenStudy's dictionary for relations.","category":"page"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"In the example below, we have a Relation Mapper file with the following information:","category":"page"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"The model CustomModel has two relations defined, one with SecondCollection and another with ThirdCollection.\nThe relation with SecondCollection is a 1_to_1 relation, and the parameter is called system. \nThe relation with ThirdCollection is a 1_to_N relation, and the parameter is called station. \nThe model SecondCollection has two relations with FourthCollection.\nThe first relation with FourthCollection is a FROM relation, and the parameter is called no1.\nThe second relation with FourthCollection is a TO relation, and the parameter is called no2.","category":"page"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"info:  Reminder\nThe relation parameter stores the reference_id from the element of the Target Collection. See PMD manual","category":"page"},{"location":"openstudy_files/relation_mapper/","page":"Relation Mapper","title":"Relation Mapper","text":"{\n    \"CustomCollection\": {\n        \"SecondCollection\": {\n            \"system\": {\n                \"is_vector\": false,\n                \"type\": \"1_TO_1\"\n            }\n        },\n        \"ThirdCollection\": {\n            \"station\": {\n                \"is_vector\": true,\n                \"type\": \"1_TO_N\"\n            }\n        }\n    },\n    \"SecondCollection\": {\n        \"FourthCollection\": {\n            \"no1\": {\n                \"is_vector\": false,\n                \"type\": \"FROM\"\n            },\n            \"no2\": {\n                \"is_vector\": false,\n                \"type\": \"TO\"\n            }\n        }\n    }\n}","category":"page"},{"location":"examples/graf_files/#Graf-Files-and-Time-Series","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"","category":"section"},{"location":"examples/graf_files/#Time-Series","page":"Graf Files and Time Series","title":"Time Series","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Some attributes in a Study represent a time series indexed by another attribute. Here we will be setting a time series for the attribute EmissionCost, from PSRGasEmission, which is indexed by DateEmissionCost.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"First we create a Dict with EmissionCost and DateEmissionCost data.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using PSRClassesInterface\nPSRI = PSRClassesInterface\nusing Dates\n\nseries = Dict{String,Vector}(\n    \"DateEmissionCost\" => [\n        Dates.Date(\"1900-01-01\"),\n        Dates.Date(\"2013-01-01\"),\n        Dates.Date(\"2013-02-01\")\n    ],\n    \"EmissionCost\" => [0.0,3.0,3.0]\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Then, we save the time series to the study using the function PSRClassesInterface.set_series!. Notice that when we are saving this time series, we are specifying the element from the collection that has this series, using its index.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"temp_path = joinpath(tempdir(), \"PSRI\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(), data_path = temp_path)\n\nPSRI.create_element!(data, \"PSRGasEmission\")\n\nPSRI.set_series!(\n    data, \n    \"PSRGasEmission\", \n    \"DateEmissionCost\",\n    1, # element index in collection\n    series\n    )","category":"page"},{"location":"examples/graf_files/#Using-a-SeriesTable","page":"Graf Files and Time Series","title":"Using a SeriesTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"We can later retrieve the series for the element in the collection with PSRClassesInterface.get_series, which will return a SeriesTable object. It can be later displayed as a table in your terminal.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"When using this function, we need the collection, the element index and the attribute that indexes the elements.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using DataFrames\nseries_table = PSRI.get_series(\n    data, \n    \"PSRGasEmission\", \n    \"DateEmissionCost\", \n    1 # element index in collection\n    )\n\nDataFrame(series_table)","category":"page"},{"location":"examples/graf_files/#Graf-files","page":"Graf Files and Time Series","title":"Graf files","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"The data relative to a Study is usually stored in a JSON file, where an attribute can have its data indexed by time intervals, as presented earlier.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"However, when a time series attribute is multidimensional, it can be too large to be stored in a JSON. For these cases, we save the data in a separate file. We will refer to such file as Graf file. When an attribute has its information in a Graf file, there's an entry in the regular JSON file specifying it. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In the following example, each PSRDemand object will have its attribute Duracao data associated with a time series, saved in the files duracao.hdr and duracao.bin. Objects are distinguished by the parmid attribute, which in this case has the AVId value of each PSRDemand element. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file stores the values of an attribute for every element in a collection. So for this example, all values for the attribute Duracao will be store in the Graf file.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"\"PSRGasEmission\": [\n    {\n        \"AVId\": \"Agent 1\"\n        \"name\": \"psr_name\"\n    },\n    {\n        \"AVId\": \"Agent 2\"\n        \"name\": \"psr_name2\"\n    },\n    {\n        \"AVId\": \"Agent 3\"\n        \"name\": \"psr_name3\"\n    }\n],\n\"GrafScenarios\": [\n    {\n        \"classname\": \"PSRDemand\",\n        \"parmid\": \"AVId\",\n        \"vector\": \"Duracao\",\n        \"binary\": [ \"duracao.hdr\", \"duracao.bin\" ]\n    }\n]","category":"page"},{"location":"examples/graf_files/#Graf-file-format","page":"Graf Files and Time Series","title":"Graf file format","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file composed of a header and a table with the following elements:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Stage \nScenario \nBlock\nAgents (one entry for each agent)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Each agent represents an element from the collection the graf file is linked to.","category":"page"},{"location":"examples/graf_files/#Visual-example-of-a-graf-file","page":"Graf Files and Time Series","title":"Visual example of a graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Using the previous example with PSRDemand objects, the Duracao for each object will be displayed in the Agents columns, that will take the name of the AVId attribute, resulting on the following:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Stg Sce Block Agent 1 Agent 2 Agent 3\n1 1 1 1.0 5.0 10.0\n1 1 2 1.5 6.5 11.5\n1 1 3 2.0 7.0 12.0\n... ... ... ... ... ...","category":"page"},{"location":"examples/graf_files/#Graf-Header","page":"Graf Files and Time Series","title":"Graf Header","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A Graf file header contains data about the time series contents. Some important information are whether the time series varies per block and/or per Scenario, the number of agents, the unit of measurement and on which stage it should start. ","category":"page"},{"location":"examples/graf_files/#Writing-a-time-series-into-a-Graf-file","page":"Graf Files and Time Series","title":"Writing a time series into a Graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In this example we will demonstrate how to save a time series into a csv or binary file.  First, we create a random array which has the data for a time series:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n#Creates dummy data\nn_blocks = 3\nn_scenarios = 1\nn_stages = 1\nn_agents = 1\n\ntime_series_data = rand(Float64, n_agents, n_blocks, n_scenarios, n_stages)\n\nnothing #hide","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"There are two ways of saving the data to a file, save the data in the file directly or iteratively. To save the data directly use the function PSRClassesInterface.array_to_file by calling:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"FILE_PATH = joinpath(tempdir(), \"example\")\n\nPSRI.array_to_file(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    time_series_data,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"H\";\n    initial_stage = 3,\n    initial_year = 2006,\n)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To save the data iteractively use the function PSRClassesInterface.open to create an PSRClassesInterface.AbstractWriter. Save the data of each registry to the file using the function PSRClassesInterface.write_registry and then close the data stream calling the function PSRClassesInterface.close.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"iow = PSRI.open(\n    PSRI.OpenBinary.Writer,\n    FILE_PATH,\n    blocks = n_blocks,\n    scenarios = n_scenarios,\n    stages = n_stages,\n    agents = [\"Agent 1\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 5\"],\n    unit = \"H\",\n    initial_stage = 1,\n    initial_year = 2006,\n)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    PSRI.write_registry(\n        iow,\n        time_series_data[:, block, scenario, stage],\n        stage,\n        scenario,\n        block\n    )\nend\n\nPSRI.close(iow)","category":"page"},{"location":"examples/graf_files/#Reading-a-time-series-from-a-graf-file","page":"Graf Files and Time Series","title":"Reading a time series from a graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"A similar logic can be used to read the data from a file. You can read it directly or iteratively. To read the data directly use the function PSRClassesInterface.file_to_array or PSRClassesInterface.file_to_array_and_header","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n\n@assert all(isapprox.(data_from_file, time_series_data, atol=1E-7))\n\ndata_from_file_and_header, header = PSRI.file_to_array_and_header(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=false\n    )\n@assert all(isapprox.(data_from_file_and_header, time_series_data, atol=1E-7))","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To choose the agents order set use_header to true and label the agents in header.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"data_from_file = PSRI.file_to_array(\n        PSRI.OpenBinary.Reader, \n        FILE_PATH;\n        use_header=true,\n        header=[\"Agent 5\", \"Agent 2\", \"Agent 3\", \"Agent 4\", \"Agent 1\"]\n    )\n@assert all(isapprox.(data_from_file[1, :, :, :], time_series_data[end, :, :, :], atol=1E-7))\n@assert all(isapprox.(data_from_file[end, :, :, :], time_series_data[1, :, :, :], atol=1E-7))","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"To read the data iteractively use the function PSRClassesInterface.open to create an PSRClassesInterface.AbstractReader and read each registry iteratively. At the end you should close the PSRClassesInterface.AbstractReader by calling PSRClassesInterface.close","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"ior = PSRI.open(\n    PSRI.OpenBinary.Reader, \n    FILE_PATH;\n    use_header = false\n)\n\ndata_from_file = zeros(n_agents, n_blocks, n_scenarios, n_stages)\n\nfor stage = 1:n_stages, scenario = 1:n_scenarios, block = 1:n_blocks\n    data_from_file[:, block, scenario, stage] = ior.data\n    PSRI.next_registry(ior)\nend\n\nPSRI.close(ior)\n","category":"page"},{"location":"examples/graf_files/#Using-Graf-files-in-a-study","page":"Graf Files and Time Series","title":"Using Graf files in a study","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"As presented earlier, an attribute for a collection can have its data stored in a Graf file, all that being specified in the GrafScenarios entry of the study JSON. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"If you have a Graf file that should be linked to a study, you can use the function PSRClassesInterface.link_series_to_file to do so.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 1\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 2\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 3\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 4\")\nPSRI.create_element!(data, \"PSRDemand\", \"AVId\" => \"Agent 5\")\n\nPSRI.link_series_to_file(\n        data, \n        \"PSRDemand\", \n        \"Duracao\", \n        \"AVId\",\n        FILE_PATH\n    )","category":"page"},{"location":"examples/graf_files/#Using-a-GrafTable","page":"Graf Files and Time Series","title":"Using a GrafTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"We can retrieve the data stored in a Graf file using the PSRClassesInterface.get_graf_series function. This function returns a GrafTable object. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"When using this function, we need the collection and its attribute that is linked to a Graf file.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"graf_table = PSRI.get_graf_series(\n        data,\n        \"PSRDemand\",\n        \"Duracao\";\n        use_header = false\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Once you have a GrafTable object, you can display it as a table in your terminal","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"using DataFrames\n\nDataFrame(graf_table)","category":"page"},{"location":"examples/graf_files/#Vector-from-graf-file","page":"Graf Files and Time Series","title":"Vector from graf file","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"You can get a vector that corresponds to a row in a Graf file with the values for the agents correspoding to the current stage, scenario and block.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"For that, we will have to use the function PSRClassesInterface.mapped_vector. ","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"vec = PSRI.mapped_vector(\n        data, \n        \"PSRDemand\", \n        \"Duracao\",\n        Float64\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"The parameters that were used to retrieve the row value in the Graf table can be changed with the following functions:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRClassesInterface.go_to_stage\nPSRClassesInterface.go_to_scenario\nPSRClassesInterface.go_to_block","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"These methods don't automatically update the vector. For that, we use the function PSRClassesInterface.update_vectors!, which update all vectors from our Study.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.update_vectors!(data)","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"However, it might be interesting to update only one or a group of vectors. To be able to do that, we will have to set a filter tag when we create them.","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"vec2 = PSRI.mapped_vector(\n        data, \n        \"PSRDemand\", \n        \"Duracao\",\n        Float64,\n        filters = [\"test_filter\"]\n    )","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"Then, when we run:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"PSRI.update_vectors!(data, \"test_filter\")","category":"page"},{"location":"examples/graf_files/#Comparison-between-a-GrafTable-and-a-SeriesTable","page":"Graf Files and Time Series","title":"Comparison between a GrafTable and a SeriesTable","text":"","category":"section"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"In this section we have introduced some new concepts about table-like types. That being said, let's review the main differences between GrafTables and SeriesTables:","category":"page"},{"location":"examples/graf_files/","page":"Graf Files and Time Series","title":"Graf Files and Time Series","text":"SeriesTable\nIs linked to a single element from a collection\nIt can have time series of different attributes that are indexed to a single attribute (all belonging to the same element)\nGrafTable\nIs linked to the whole collection. So for an attribute, every element in the collection will have an entry in the graf file\nIt has the time series for only one attribute","category":"page"},{"location":"examples/custom_study/#Customizing-a-Study","page":"Customizing a Study","title":"Customizing a Study","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"In this tutorial you will learn how to customize several items of your study.","category":"page"},{"location":"examples/custom_study/#How-we-define-the-template-for-our-studies","page":"Customizing a Study","title":"How we define the template for our studies","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"First of all, it's important to understand how we define the default rules for each collection in our study.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"Let's take a look at the function PSRClassesInterface.create_study for the OpenStudy interface. It has the following signature:","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"function create_study(\n    ::OpenInterface;\n    data_path::AbstractString = pwd(),\n    pmd_files::Vector{String} = String[],\n    pmds_path::AbstractString = PMD._PMDS_BASE_PATH,\n    defaults_path::Union{AbstractString,Nothing} = PSRCLASSES_DEFAULTS_PATH,\n    defaults::Union{Dict{String,Any},Nothing} = _load_defaults!(),\n    netplan::Bool = false,\n    model_template_path::Union{String,Nothing} = nothing,\n    study_collection::String = \"PSRStudy\",\n)","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"From our other examples, you will notice that we have never filled most of these parameters, leaving them with their default values. However, the following are important for working with custom Studies:","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"pmd_files or pmds_path\nmodel_template_path\ndefaults_path","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"A PMD is a .pmd file where we define collections and the metadata for each of their attributes. A Model Template is a JSON file where we map the name of collections in the PMD to their names in our Study. Finally, Defaults is also a JSON file where we set the default values for some - or all - attributes in collections.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When we create a study, we parse the PMD file(s) and the Model Template, creating the data.data_struct, a Dict that contains the metadata for attributes and their names. ","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When we create an element, PSRI uses data.data_struct to check if the values for the attributes that we have filled are in agreement with their definition(if they should be Vectors, Floats, ...) and if any attribute is missing. ","category":"page"},{"location":"examples/custom_study/#Defining-custom-structures-with-new-PMD-file","page":"Customizing a Study","title":"Defining custom structures with new PMD file","text":"","category":"section"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"When you already have your structures defined in a PMD file, you don't need to create them in runtime. First, save this code as a .pmd file, where we define a Study collection, different from PSRStudy and a PSRExtra collection. ","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"DEFINE_MODEL MODL:Custom_Study_Config\n\tPARM REAL \t\tValue1\n\tPARM REAL \t\tValue3\n\tPARM STRING     Text\nEND_MODEL\n\nDEFINE_MODEL MODL:Extra_Collection\n\tPARM REAL \t\tExtraValue\n\tPARM STRING     Text\nEND_MODEL","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"Now we need a Model Template file, to map our PMD Model to collections. Just as we did before, copy the following code into a file, but save it as a .json this time.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"[\n    {\n        \"classname\": \"CustomStudy\",\n        \"models\": [\"Custom_Study_Config\"]\n    },\n    {\n        \"classname\": \"PSRExtra\",\n        \"models\": [\"Extra_Collection\"]\n    }\n]","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"After that, we can create a Study with PSRClassesInterface.create_study using a few extra mandatory parameters.","category":"page"},{"location":"examples/custom_study/","page":"Customizing a Study","title":"Customizing a Study","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\n\ntemp_path = joinpath(tempdir(), \"PSRI\")\njson_path = joinpath(path_to_directory, \"custom_json.json\")\n\ndata = PSRI.create_study(PSRI.OpenInterface(), \n    data_path = temp_path, \n    pmds_path = path_to_directory, \n    model_template_path = json_path, \n    study_collection = \"CustomStudy\", \n    defaults = Dict{String,Any}(\n        \"CustomStudy\" => Dict{String,Any}(\n            \"AVId\" => \"avid\", \n            \"Text\" => \"custom\", \n            \"Value1\" => 1.0, \n            \"Value3\" => 2.0, \n            \"code\" => Int32(10), \n            \"name\" => \"name\"\n        )\n    )\n)\n","category":"page"},{"location":"examples/reading_demands/#Reading-Demands","page":"Reading Demands","title":"Reading Demands","text":"","category":"section"},{"location":"examples/reading_demands/#Determining-elasticity-and-value-of-demands","page":"Reading Demands","title":"Determining elasticity and value of demands","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"In this example we will read demand segments, obtain the value of demands, discover wheter each demand is elastic or inelastic, and then obtain the sums of demands by elasticity. The first step is to read the study data:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"using PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_DEM = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_DEM\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Whereas the demand varies according to the stage, we must specify the stage by calling go_to_stage:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"target_stage = 1\nPSRI.go_to_stage(data,target_stage)","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now, we can read the demand segments and the map between demands and demand segments, and then obtain the value of each demand:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"dem_seg = PSRI.mapped_vector(data, \"PSRDemandSegment\", \"Demanda\", Float64, \"block\")\n\nseg2dem = PSRI.get_map(data, \"PSRDemandSegment\", \"PSRDemand\", relation_type = PSRI.PMD.RELATION_1_TO_1)\n\ndem_size = PSRI.max_elements(data, \"PSRDemand\")\n\ndemand_values = zeros(dem_size)\n\nfor demand = 1:dem_size\n    demand_values[demand] = sum(dem_seg[i] for i = 1:length(dem_seg) if seg2dem[i] == demand)\nend\n\ndemand_values","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"We can discover the elasticity of each demand by calling get_parms with the parameter Elastico:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"demands_elasticity = PSRI.get_parms(data, \"PSRDemand\", \"Elastico\", Int32)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"If demands_elasticity[i] == 0 it means that the demand at index i is inelastic, and elastic if demands_elasticity[i] == 1. We can now obtain the total demands of each elasticity:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"total_elastic_demand = 0.0\ntotal_inelastic_demand = 0.0\n\nfor i = 1:dem_size\n    if demands_elasticity[i] == 0\n        total_inelastic_demand += demand_values[i]\n    else\n        total_elastic_demand += demand_values[i]\n    end\nend","category":"page"},{"location":"examples/reading_demands/#Determining-demands-values-of-each-bus","page":"Reading Demands","title":"Determining demands values of each bus","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we have the values of the demands, we can obtain the values of demand for each bus.  Each demand has a set of loads, which define how much of this demand corresponds to each bus.  We can begin by reading the loads and its relations with demands and buses:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"loads = PSRI.mapped_vector(data, \"PSRLoad\", \"P\", Float64, \"block\")\nlod2dem = PSRI.get_map(data, \"PSRLoad\", \"PSRDemand\", relation_type = PSRI.PMD.RELATION_1_TO_1)\nlod2bus = PSRI.get_map(data, \"PSRLoad\", \"PSRBus\", relation_type = PSRI.PMD.RELATION_1_TO_1)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"The values of the loads are weights in a kind of a weighted arithmetic mean of the buses for each demand. But the loads of each demand don't add up to 1, so they need to be normalized to represent fractions of the total:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"total_lod_bydem = zeros(dem_size)\nlod_size = PSRI.max_elements(data, \"PSRLoad\")\n\nfor i in 1:lod_size\n    total_lod_bydem[lod2dem[i]] += loads[i]\nend\n\nfor i in 1:lod_size\n    if total_lod_bydem[lod2dem[i]] > 0.0\n        loads[i] = loads[i]/total_lod_bydem[lod2dem[i]]\n    else\n        loads[i] = 0.0\n    end\nend\n\nloads","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we know the fraction of each demand that corresponds to each bus, and can easily define the total demand by bus:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"bus_size = PSRI.max_elements(data, \"PSRBus\")\n\ndem_bybus = zeros(bus_size)\n\nfor lod = 1:lod_size\n    fraction = loads[lod]\n    dem = lod2dem[lod]\n    bus = lod2bus[lod] \n    dem_bybus[bus] += demand_values[dem]*fraction\nend\n\ndem_bybus","category":"page"},{"location":"examples/reading_demands/#Calculating-the-energy-prices-of-each-thermal-plant","page":"Reading Demands","title":"Calculating the energy prices of each thermal plant","text":"","category":"section"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"The energy prices in a thermal plant deppends on the  the price of the fuel used, the specific consumption of this fuel and Operation and Maintenance cost. Again, we begin by reading the data:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"import PSRClassesInterface\nconst PSRI = PSRClassesInterface\n\nPATH_CASE_EXAMPLE_THER_PRICES = joinpath(pathof(PSRI) |> dirname |> dirname, \"test\", \"data\", \"case1\")\n\ndata = PSRI.load_study(\n    PSRI.OpenInterface(),\n    data_path = PATH_CASE_EXAMPLE_THER_PRICES\n)\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"We discover the necessary infos of the thermal plants indirectly through PSRFuelConsumption:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"fuelcons2ther = PSRI.get_map(data,\"PSRFuelConsumption\", \"PSRThermalPlant\"; relation_type = PSRI.PMD.RELATION_1_TO_1)\n\nther_size = PSRI.max_elements(data, \"PSRThermalPlant\")\nfuelcons_size = PSRI.max_elements(data, \"PSRFuelConsumption\")\nther2fuelcons = [[fc for fc = 1:fuelcons_size if fuelcons2ther[fc] == t] for t = 1:ther_size]\n; nothing # hide","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Next, we get the O&M cost, the specific consumption and the relation with fuels of our fuels consumptions. Then we get the cost of each fuel. After calling mapped_vector we must call update_vectors!.","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"om_cost = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"O&MCost\", Float64)\nspec_consum = PSRI.mapped_vector(data, \"PSRFuelConsumption\", \"CEsp\", Float64, \"segment\", \"block\")\nfuelcons2fuel = PSRI.get_map(data, \"PSRFuelConsumption\", \"PSRFuel\"; relation_type = PSRI.PMD.RELATION_1_TO_1)\nfuel_cost = PSRI.mapped_vector(data, \"PSRFuel\", \"Custo\", Float64)\n\nPSRI.update_vectors!(data)","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"Now we can calculate the price of the energy unity of each fuel consumption for each thermal plant:","category":"page"},{"location":"examples/reading_demands/","page":"Reading Demands","title":"Reading Demands","text":"ther_prices = [zeros(0) for _ = 1:ther_size]\nfor ther = 1:ther_size\n    n_fuelcons = length(ther2fuelcons[ther])\n    prices = zeros(n_fuelcons)\n    for i = 1:n_fuelcons\n        fuelcons = ther2fuelcons[ther][i]\n        fuel = fuelcons2fuel[fuelcons]\n        prices[i] = om_cost[fuelcons] + spec_consum[fuelcons]*fuel_cost[fuel]\n    end\n    ther_prices[ther] = prices\nend\nther_prices","category":"page"},{"location":"openstudy_files/pmd/#PMD","page":"PMD","title":"PMD","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"tip: Tip\nWe have a syntax highlighter for .pmd files available on Visual Studio's Marktetplace","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"warning: Warning\nThe syntax for PMD files is case-sensitive ","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"PMD files are used to define models accross multiple PSR software. It stores metadata about every attribute and relation.","category":"page"},{"location":"openstudy_files/pmd/#Good-practices","page":"PMD","title":"Good practices","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"In order to make the PMD file more readable and easier to maintain, we recommend the following good practices:","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"Decide whether you want to use PascalCase, snake_case or camelCase and stick to it.\nAlways write the name for the Attributes and Collections in English.\nDo not use special characters other than \"_\" (underscore) in the names.\nDefine understandable names for the Attributes and Collections, as other users may use your model in the future.","category":"page"},{"location":"openstudy_files/pmd/#Defining-a-model","page":"PMD","title":"Defining a model","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"To define a model Custom_Model_v1, you need to use the following structure:","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"DEFINE_MODEL MODL:Custom_Model_v1\n\n\t...\n\nEND_MODEL","category":"page"},{"location":"openstudy_files/pmd/#Defining-a-parameter","page":"PMD","title":"Defining a parameter","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"A parameter can be either a VECTOR or a PARM.","category":"page"},{"location":"openstudy_files/pmd/#PARM","page":"PMD","title":"PARM","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"DEFINE_MODEL MODL:Custom_Model_v1\n\n\t...\n\n\tPARM INTEGER Iterations\n\tPARM REAL Price\n\tPARM STRING Name\n\tPARM DATE DateOfEvent\n\n\t...\n\nEND_MODEL","category":"page"},{"location":"openstudy_files/pmd/#VECTOR","page":"PMD","title":"VECTOR","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"A VECTOR parameter can store the same types as a PARM. Additionally can have an indexing parameter attribute.","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"Let's say that you have a vector Cost where each index corresponds to a cost in a specific date. We can use an auxiliary indexing vector CostDates to access the cost value correspondent to a given date (see the Graf Files and Time Series example).","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"DEFINE_MODEL MODL:Custom_Model_v1\n\n\t...\n\n\tVECTOR DATE CostDates\n\tVECTOR REAL Cost INDEX CostDates\n\n\t...\n\nEND_MODEL","category":"page"},{"location":"openstudy_files/pmd/#Parameters-with-dimension","page":"PMD","title":"Parameters with dimension","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"A VECTOR or PARM parameter can change according to a given Stage, Scenario and/or Block dimension (see the Graf Files and Time Series example). We can specify whether a parameter is dimensioned using the following syntax:","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"DEFINE_MODEL MODL:Custom_Model_v1\n\n\t...\n\n\tPARM INTEGER Iterations DIM(block)\n\n\tVECTOR REAL Duration DIM(block) \n\n\tVECTOR DATE CostDates\n\tVECTOR REAL Cost DIM(block,segment) INDEX CostDates \n\n\t...\n\nEND_MODEL","category":"page"},{"location":"openstudy_files/pmd/#REFERENCE","page":"PMD","title":"REFERENCE","text":"","category":"section"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"Besides REAL, INTEGER, STRING and DATE, there is a fith attribute type labeled REFERENCE.  It can be stored either in a VECTOR or a PARM.","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"A REFERENCE represents a relation between two models(or collections, when considering a PSRI study).","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"It has the following structure:","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"DEFINE_MODEL MODL:Custom_Model_v1\n\n\t...\n\n\tPARM REFERENCE Plant TargetCollection  \n\n\tVECTOR REFERENCE Items SecondTargetCollection\n\n\t...\n\nEND_MODEL","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"In this example, our CustomModelv1 model has two relations:","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"a relation of 1 to 1 (for being a PARM parameter) with elements of collection TargetCollection\na relation of 1 to N (for being a VECTOR parameter) with elements of collection SecondTargetCollection","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"The Plant and Items parameters store the reference_id of the corresponding elements from collections TargetCollection and SecondTargetCollection, respectively.","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"Note that the names TargetCollection and SecondTargetCollection are the name of the collections inside the study, not their name in the PMD file.  This difference between names is explained in the Model Template manual.","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"Also, we define a REFERENCE only in the models which play the role of source. ","category":"page"},{"location":"openstudy_files/pmd/","page":"PMD","title":"PMD","text":"There is another way to define relations in a study. For that, see the Relation Mapper manual.","category":"page"},{"location":"sqlite_examples/migrations/#Migration-Examples","page":"Migration Examples","title":"Migration Examples","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Migrations are a way to manage the evolution of the database schema over time. As mentioned in the documentation for PSRDatabaseSQLite, migrations are defined by two separate .sql files that are stored in the migrations directory of the model. The first file is the up migration and it is used to update the database schema to a new version. The second file is the down migration and it is used to revert the changes made by the up migration. Migrations are stored in directories in the model and they have a specific naming convention. The name of the migration folder should be the number of the version (e.g. /migrations/1/).","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"In this section, we will provide some examples of migrations. First, let us start with the first migration, the one that creates the initial database schema.","category":"page"},{"location":"sqlite_examples/migrations/#Adding-two-tables-to-the-database","page":"Migration Examples","title":"Adding two tables to the database","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 1; -- Set the database version to 1\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Configuration table\nCREATE TABLE Configuration (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    value TEXT NOT NULL\n) ;\n\n-- Create Plant table\nCREATE TABLE Plant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL\n) ;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This schema is the up.sql migration for version 1. It creates two tables, Configuration and Plant. Now we have to create the down.sql migration for version 1. This migration should drop the tables created in the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 0; -- Set the database version to 0\n-- Drop the Configuration table\nDROP TABLE Configuration;\n-- Drop the Plant table\nDROP TABLE Plant;","category":"page"},{"location":"sqlite_examples/migrations/#Adding-a-new-column","page":"Migration Examples","title":"Adding a new column","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Now let us create a migration that adds a new column to the Configuration and Plant tables.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 2; -- Set the database version to 2\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Add the description column to the Configuration table\nALTER TABLE Configuration ADD COLUMN description TEXT;\n\n-- Add the type column to the Plant table\nALTER TABLE Plant ADD COLUMN type INTEGER NOT NULL DEFAULT 0;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 2. The down.sql migration should remove the column added in the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 1; -- Set the database version to 1\n\n-- Remove the description column from the Configuration table\nALTER TABLE Configuration DROP COLUMN description;\n\n-- Remove the type column from the Plant table\nALTER TABLE Plant DROP COLUMN type;","category":"page"},{"location":"sqlite_examples/migrations/#Renaming-a-table","page":"Migration Examples","title":"Renaming a table","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that renames the Plant table to PowerPlant.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 3; -- Set the database version to 3\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Rename the Plant table to PowerPlant\nALTER TABLE Plant RENAME TO PowerPlant;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 3. The down.sql migration should rename the PowerPlant table back to Plant.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 2; -- Set the database version to 2\n\n-- Rename the PowerPlant table to Plant\nALTER TABLE PowerPlant RENAME TO Plant;","category":"page"},{"location":"sqlite_examples/migrations/#Adding-a-foreign-key-constraint","page":"Migration Examples","title":"Adding a foreign key constraint","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that adds a foreign key constraint to the PowerPlant table. First, we need to create a new table, Resource, that will be referenced by the PowerPlant table.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Adding a foreign key constraint, however, is not as trivial as adding a column or renaming a table. We need to follow these steps:","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Disable foreign key constraints\nStart a transaction\nCreate an auxiliary new_PowerPlant table with the new column and the foreign key constraint\nCopy the data from the PowerPlant table to the new_PowerPlant table\nDrop the PowerPlant table\nRename the new_PowerPlant table to PowerPlant\nCheck if any foreign key constraints were violatet with PRAGMA foreign_key_check\nCommit the transaction\nEnable foreign key constraints ","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 4; -- Set the database version to 4\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Resource table\nCREATE TABLE Resource (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL\n) ;\n\n-- Disable foreign key constraints\nPRAGMA foreign_keys = OFF;\n\n-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Create the new PowerPlant table\nCREATE TABLE new_PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the PowerPlant table to the new PowerPlant table\nINSERT INTO new_PowerPlant (id, label, capacity, bus_name, type)\nSELECT id, label, capacity, bus_name, type FROM PowerPlant;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\n-- Rename the new PowerPlant table to PowerPlant\nALTER TABLE new_PowerPlant RENAME TO PowerPlant;\n\n-- Check if any foreign key constraints were violated\nPRAGMA foreign_key_check;\n\n-- Commit the transaction\nCOMMIT;\n\n-- Enable foreign key constraints\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Now, the down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 3; -- Set the database version to 3\n\n-- Disable foreign key constraints\nPRAGMA foreign_keys = OFF;\n\n-- Start a transaction\nBEGIN TRANSACTION;\n\n-- Create the new PowerPlant table\nCREATE TABLE new_PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0\n) ;\n\n-- Copy the data from the PowerPlant table to the new PowerPlant table\nINSERT INTO new_PowerPlant (id, label, capacity, bus_name, type)\nSELECT id, label, capacity, bus_name, type FROM PowerPlant;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\n-- Rename the new PowerPlant table to PowerPlant\nALTER TABLE new_PowerPlant RENAME TO PowerPlant;\n\n-- Check if any foreign key constraints were violated\nPRAGMA foreign_key_check;\n\n-- Commit the transaction\nCOMMIT;\n\n-- Enable foreign key constraints\nPRAGMA foreign_keys = ON;\n\n-- Drop the Resource table\nDROP TABLE Resource;","category":"page"},{"location":"sqlite_examples/migrations/#Dividing-a-table-into-two-tables","page":"Migration Examples","title":"Dividing a table into two tables","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that divides the PowerPlant table into two tables, HydroPlant and ThermalPlant.  HydroPlant corresponds to the rows with type = 0 and ThermalPlant corresponds to the rows with type = 1.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 5; -- Set the database version to 5\n\n\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Create the HydroPlant table\nCREATE TABLE HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Create the ThermalPlant table\nCREATE TABLE ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Fill the HydroPlant table\nINSERT INTO HydroPlant (id, label, capacity, bus_name, resource_id)\nSELECT id, label, capacity, bus_name, resource_id FROM PowerPlant WHERE type = 0;\n\n-- Fill the ThermalPlant table\nINSERT INTO ThermalPlant (id, label, capacity, bus_name, resource_id)\nSELECT id, label, capacity, bus_name, resource_id FROM PowerPlant WHERE type = 1;\n\n-- Drop the PowerPlant table\nDROP TABLE PowerPlant;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;\n","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 5. The down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 4; -- Set the database version to 4\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the PowerPlant table\nCREATE TABLE PowerPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    type INTEGER NOT NULL DEFAULT 0,\n    bus_name TEXT NOT NULL,\n    resource_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Fill the PowerPlant table\nINSERT INTO PowerPlant (id, label, capacity, bus_name, type, resource_id)\nSELECT id, label, capacity, bus_name, 0, resource_id FROM HydroPlant;\n\nINSERT INTO PowerPlant (id, label, capacity, bus_name, type, resource_id)\nSELECT id, label, capacity, bus_name, 1, resource_id FROM ThermalPlant;\n\n-- Drop the HydroPlant table\nDROP TABLE HydroPlant;\n\n-- Drop the ThermalPlant table\nDROP TABLE ThermalPlant;","category":"page"},{"location":"sqlite_examples/migrations/#Create-a-table-with-data-from-another-table","page":"Migration Examples","title":"Create a table with data from another table","text":"","category":"section"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"Let us create a migration that adds a new Table Bus with data from the HydroPlant and ThermalPlant tables. These tables already have a column bus_name that will be used to fill the Bus table. After creating the Bus table, we will remove the bus_name column from the HydroPlant and ThermalPlant tables. Moreover, the bus_name column in the PowerPlant table will be replaced by a bus_id column that references the Bus table.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 6; -- Set the database version to 6\nPRAGMA foreign_keys = ON; -- Enable foreign keys to enforce referential integrity\n\n-- Create the Bus table\nCREATE TABLE Bus (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL\n) ;\n\n-- Fill the Bus table\nINSERT INTO Bus (label)\nSELECT DISTINCT bus_name FROM HydroPlant;\n\nINSERT INTO Bus (label)\nSELECT DISTINCT bus_name FROM ThermalPlant;\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Add foreign key \nCREATE TABLE new_HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY (bus_id) REFERENCES Bus(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\nCREATE TABLE new_ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_id INTEGER,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY (bus_id) REFERENCES Bus(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the HydroPlant table to the new HydroPlant table\nINSERT INTO new_HydroPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM HydroPlant;\n\n-- Copy the data from the ThermalPlant table to the new ThermalPlant table\nINSERT INTO new_ThermalPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM ThermalPlant;\n\n-- Add data for the bus_id column\nUPDATE new_HydroPlant SET bus_id = (SELECT Bus.id FROM Bus\nINNER JOIN HydroPlant ON Bus.label = HydroPlant.bus_name AND \nHydroPlant.id = new_HydroPlant.id\n);\nUPDATE new_ThermalPlant SET bus_id = (SELECT Bus.id FROM Bus\nINNER JOIN ThermalPlant ON Bus.label = ThermalPlant.bus_name AND\nThermalPlant.id = new_ThermalPlant.id\n);\n\n-- Drop tables\nDROP TABLE HydroPlant;\nDROP TABLE ThermalPlant;\n\n-- Rename tables\nALTER TABLE new_HydroPlant RENAME TO HydroPlant;\nALTER TABLE new_ThermalPlant RENAME TO ThermalPlant;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"This is the up.sql migration for version 6. The down.sql migration should revert the changes made by the up.sql migration.","category":"page"},{"location":"sqlite_examples/migrations/","page":"Migration Examples","title":"Migration Examples","text":"PRAGMA user_version = 5; -- Set the database version to 5\n\n\nPRAGMA foreign_keys = OFF;\nBEGIN TRANSACTION;\n\n-- Create auxiliary tables\nCREATE TABLE new_HydroPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_name TEXT,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\nCREATE TABLE new_ThermalPlant (\n    id INTEGER PRIMARY KEY,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    resource_id INTEGER,\n    bus_name TEXT,\n    FOREIGN KEY (resource_id) REFERENCES Resource(id) ON UPDATE CASCADE ON DELETE CASCADE\n) ;\n\n-- Copy the data from the HydroPlant table to the new HydroPlant table\nINSERT INTO new_HydroPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM HydroPlant;\n\n-- Copy the data from the ThermalPlant table to the new ThermalPlant table\nINSERT INTO new_ThermalPlant (id, label, capacity, resource_id)\nSELECT id, label, capacity, resource_id FROM ThermalPlant;\n\n-- Add data for the bus_name column\nUPDATE new_HydroPlant SET bus_name = (SELECT Bus.label FROM Bus\nINNER JOIN HydroPlant ON Bus.id = HydroPlant.bus_id AND \nHydroPlant.id = new_HydroPlant.id\n);\n\nUPDATE new_ThermalPlant SET bus_name = (SELECT Bus.label FROM Bus\nINNER JOIN ThermalPlant ON Bus.id = ThermalPlant.bus_id AND\nThermalPlant.id = new_ThermalPlant.id\n);\n\n-- Drop tables\nDROP TABLE HydroPlant;\nDROP TABLE ThermalPlant;\n\n-- Rename tables\nALTER TABLE new_HydroPlant RENAME TO HydroPlant;\nALTER TABLE new_ThermalPlant RENAME TO ThermalPlant;\n\n-- Drop the Bus table\nDROP TABLE Bus;\n\nPRAGMA foreign_key_check;\nCOMMIT;\nPRAGMA foreign_keys = ON;","category":"page"},{"location":"psrdatabasesqlite/rules/#PSRDatabaseSQLite","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Following PSRI's OpenStudy standards, SQL schemas for the PSRDatabaseSQLite framework should follow the conventions described in this document. Note that this is a tool for creating and developing some kinds of applications. Not all tools will need to use this framework.","category":"page"},{"location":"psrdatabasesqlite/rules/#SQL-Schema-Conventions","page":"PSRDatabaseSQLite","title":"SQL Schema Conventions","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/#Collections","page":"PSRDatabaseSQLite","title":"Collections","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"The Table name should be the same as the name of the Collection.\nThe Table name of a Collection should beging with a capital letter and be in singular form.\nIn case of a Collection with a composite name, the Table name should written in Pascal Case.\nThe Table must contain a primary key named id that is an INTEGER. You should use the AUTOINCREMENT keyword to automatically generate the id for each element.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Examples:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE Resource (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    some_type TEXT\n) STRICT;\n\nCREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL DEFAULT 0\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/#Configuration-collection","page":"PSRDatabaseSQLite","title":"Configuration collection","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Every database definition must have a Configuration, which will store information from the case.  The column label is not mandatory for a Configuration collection.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE Configuration (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    value1 REAL NOT NULL DEFAULT 100,\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/#Non-vector-Attributes","page":"PSRDatabaseSQLite","title":"Non-vector Attributes","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"The name of an Attribute should be in snake case and be in singular form.\nIf the attribute's name is label, it should be stored as a TEXT and have the UNIQUE and NOT NULL constraints.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL NOT NULL\n    some_example_of_attribute REAL\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"If an attribute name starts with date it should be stored as a TEXT and indicates a date that will be mapped to a DateTime object.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE ThermalPlant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    minimum_generation REAL NOT NULL,\n    date_of_construction TEXT\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"If an attribute name starts with the name of another collection it should be stored as a INTEGER and indicates a relation with another collection. It should never have the NOT NULL constraint. All references should always declare the ON UPDATE CASCADE ON DELETE CASCADE constraint. In the example below the attribute gaugingstation_id indicates that the collection Plant has an id relation with the collection GaugingStation and the attribute plant_spill_to indicates that the collection Plant has a spill_to relation with itself.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE Plant(\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    label TEXT UNIQUE NOT NULL,\n    capacity REAL NOT NULL,\n    gaugingstation_id INTEGER,\n    plant_spill_to INTEGER,\n    FOREIGN KEY(gaugingstation_id) REFERENCES GaugingStation(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    FOREIGN KEY(plant_spill_to) REFERENCES Plant(id) ON UPDATE SET NULL ON DELETE CASCADE\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/#Vector-Attributes","page":"PSRDatabaseSQLite","title":"Vector Attributes","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"In case of a vector attribute, a table should be created with its name indicating the name of the Collection and the name of a group of the attribute, separated by _vector_, such as COLLECTION_vector_GROUP_OF_ATTRIBUTES.\nThe table must contain a Column named id and another named vector_index.\nThere must be a Column named after the attributes names, which will store the value of the attribute for the specified element id and index vector_index.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"These groups are used to store vectors that should have the same size. If two vectors don't necessarily have the same size, they should be stored in different groups.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE ThermalPlant_vector_some_group(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    some_value REAL NOT NULL,\n    some_other_value REAL,\n    FOREIGN KEY (id) REFERENCES ThermalPlant(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example of a small time series","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE ThermalPlant_vector_some_group(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    date_of_modification REAL NOT NULL,\n    capacity REAL,\n    FOREIGN KEY (id) REFERENCES ThermalPlant(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"A vector relation with another collection should be stored in a table of vector groups and be defined the same way as a vector attribute. To tell that it is a relation with another collection, the name of the relational attribute should be the name of the target collection followed by the relation type defined as _relation_type, i.e. gaugingstation_id indicated that the collection HydroPlant has an id relation with the collection GaugingStation. If the name of the attribute was gaugingstation_one_to_one, it would indicate that the collection HydroPlant has a relation one_to_one with the collection GaugingStation.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE HydroPlant_vector_gauging_station(\n    id INTEGER,\n    vector_index INTEGER NOT NULL,\n    conversion_factor REAL NOT NULL,\n    gaugingstation_id INTEGER,\n    FOREIGN KEY (gaugingstation_id) REFERENCES GaugingStation(id) ON UPDATE CASCADE ON DELETE CASCADE,\n    PRIMARY KEY (id, vector_index)\n) STRICT;\n","category":"page"},{"location":"psrdatabasesqlite/rules/#Time-Series-Files","page":"PSRDatabaseSQLite","title":"Time Series Files","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"All Time Series files for the elements from a Collection should be stored in a Table\nThe Table name should be the same as the name of the Collection followed by _time_series_files, such as COLLECTION_vector_ATTRIBUTE.\nEach Column of the table should be named after the name of the attribute.\nEach Column should store the path to the file containing the time series data.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE Plant_time_series_files (\n    generation TEXT,\n    cost TEXT\n) STRICT;","category":"page"},{"location":"psrdatabasesqlite/rules/#Time-Series","page":"PSRDatabaseSQLite","title":"Time Series","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Time Series stored in the database should be stored in a table with the name of the Collection followed by _time_series_ and the name of the attribute group, such a COLLECTION_time_series_GROUP_OF_ATTRIBUTES.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Notice that it is quite similar to the vector attributes, but without the vector_index column. Instead, a mandatory column named date_time should be created to store the date of the time series data.","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Example:","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"CREATE TABLE Resource_time_series_group1 (\n    id INTEGER, \n    date_time TEXT NOT NULL,\n    some_vector1 REAL,\n    some_vector2 REAL,\n    FOREIGN KEY(id) REFERENCES Resource(id) ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (id, date_time)\n) STRICT; ","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"tip: Tip\n","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"For more information on how to handle time series data, please refer to the Time Series section.","category":"page"},{"location":"psrdatabasesqlite/rules/#Migrations","page":"PSRDatabaseSQLite","title":"Migrations","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"Migrations are an important part of the DatabaseSQLite framework. They are used to update the database schema to a new version without the need to delete the database and create a new one from scratch. Migrations are defined by two separate .sql files that are stored in the migrations directory of the model. The first file is the up migration and it is used to update the database schema to a new version. The second file is the down migration and it is used to revert the changes made by the up migration. Migrations are stored in directories in the model and they have a specific naming convention. The name of the migration folder should be the number of the version (e.g. /migrations/1/).","category":"page"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"database/migrations\n 1\n    up.sql\n    down.sql\n 2\n     up.sql\n     down.sql","category":"page"},{"location":"psrdatabasesqlite/rules/#Creating-a-migration","page":"PSRDatabaseSQLite","title":"Creating a migration","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"It is advised to create new migrations using the functions from DatabaseSQLite. First you need to make sure that the migrations directory is registered  by the function DatabaseSQLite.set_migrations_folder and after that you can create a new migration using the function DatabaseSQLite.create_migration. This function will create a new migration file with the name and version specified by the user. The migration file will contain a template for the migration.","category":"page"},{"location":"psrdatabasesqlite/rules/#Running-migrations","page":"PSRDatabaseSQLite","title":"Running migrations","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"To run migrations you need to use the function DatabaseSQLite.apply_migrations!. There are various versions of this function, each one tailored to make something easier for the user.","category":"page"},{"location":"psrdatabasesqlite/rules/#Testing-migrations","page":"PSRDatabaseSQLite","title":"Testing migrations","text":"","category":"section"},{"location":"psrdatabasesqlite/rules/","page":"PSRDatabaseSQLite","title":"PSRDatabaseSQLite","text":"It is very important to test if the migrations of a certain model are working as expected, so the user can be sure that the database schema is updated correctly. To test migrations you need to use the function DatabaseSQLite.test_migrations(). It is highly advised that each model has one of these functions in their test suite to make sure that the migrations are working as expected.","category":"page"},{"location":"#PSRClassesInterface-Documentation","page":"Home","title":"PSRClassesInterface Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PSRClassesInterface, or PSRI, is a Julia package that provides an interface to read and write open-source formats for PSR models. It is comprised of three main modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenStudy: Reads and writes data in the JSON format\nOpenBinary: Reads and writes time series data in the binary format\nPSRDatabaseSQLite: Reads and writes data in the SQL format","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered so you can simply add it using Julia's Pkg manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"PSRClassesInterface\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide","category":"page"}]
}
